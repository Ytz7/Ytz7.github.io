<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七号zz の Blog</title>
  
  <subtitle>愿为未来做牛马。</subtitle>
  <link href="https://ytz7.github.io/atom.xml" rel="self"/>
  
  <link href="https://ytz7.github.io/"/>
  <updated>2023-05-21T12:08:10.865Z</updated>
  <id>https://ytz7.github.io/</id>
  
  <author>
    <name>七号zz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unsupervised-Data-Augmentation</title>
    <link href="https://ytz7.github.io/posts/77eb0ac8.html"/>
    <id>https://ytz7.github.io/posts/77eb0ac8.html</id>
    <published>2023-05-18T10:55:32.000Z</published>
    <updated>2023-05-21T12:08:10.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Unsupervised Data Augmentation for Consistency Training</p></blockquote><p>会议：NeurIPS 2019</p><p>论文地址：<a href="https://arxiv.org/abs/1904.12848v2"> Unsupervised Data Augmentation for Consistency Training</a></p><p>Pytorch 复现：<a href="https://github.com/sndnyang/vat_pytorch">sndnyang/vat_pytorch</a></p><p>参考文章：</p><ul><li><a href="https://amitness.com/2020/07/semi-supervised-learning/">Semi-Supervised Learning in Computer Vision</a></li><li><a href="https://blog.csdn.net/by6671715/article/details/122706003">码侯烧酒的博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/369023559">Unsupervised Data Augmentation for Consistency Training </a></li></ul><p>参考视频：</p><ul><li><a href="https://www.bilibili.com/video/BV1Ab4y1S7i5/?spm_id_from=333.999.0.0&amp;vd_source=7801e0201bc8ddcb3d951c7388a08c3e">数最后一名</a></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>最近的半监督学习方式都是基于一致性学习（consistency training）的，尽管成果不错，但是它们添加噪声的方式都比较初级，大多数都是基于 Gaussian noise， dropout noise 或者是 adversarial noise。因此，作者想引入一些更高级的数据增强方式，尤其是那些在监督学习中已经证明有效的方法，看看它们在半监督学习中是否也是有效的。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>少样本标注情况下，充分利用无标注数据，使其尽可能达到有充分标注的效果。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据一致性训练的原则，认为对一个样本进行较好的数据增强后，预测标签不应该发生变化，因此一般来说会有两个部分的 loss：（1）标注样本的损失，一般采用<code>交叉熵</code>；（2）未标注样本的损失，<code>KL 散度</code>等。</p><p>流程图如下所示，对有标签样本计算损失 L1，对无标签样本执行一次预测得到一个结果，再对改变本做一次特殊的数据增强后在进行预测得到一个结果，将两个结果计算一致性损失 L2，将 L1 与 L2 计算加权和。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519192319207.png" alt="image-20230519192319207"></p><p>数学形式说明该流程，输入 <code>x</code>，计算输入分布 <code>p_θ(y|x)</code> 和带噪声的分布 <code>p_θ(y|x, ɛ)</code>，然后最小化两个分布之间的距离：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519193105506.png" alt="image-20230519193105506"></p><p>上述图片对应的损失函数如下所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519193157993.png" alt="image-20230519193157993"></p><p>其中，<code>λ</code> 为平衡有监督学习和一致性训练之间的损失，<code>CE</code> 为交叉熵，<code>f*(.)</code> 为索要训练的最终目标模型。</p><p><u><strong>但有一点很奇怪</strong></u>，作者在之前的版本中计算一致性损失所采用的计量方式为 KL 散度，但是在最新版本又换回了 Cross-Entropy，不懂这是为什么…可能看效果而异吧。</p><p>不过有的人说：</p><blockquote><p>MSE 和 KL 散度各有优劣，二者的选取与数据集的实际分布特征关系很大，在实践中不妨进行对比测试</p></blockquote><p>在论文中，作者正对计算机视觉和自然语言任务提出了不同的对应增强方法，其中对于图片的增强方式，作者使用了一个增强方法 <u><strong>RandAugment</strong></u>，（只了解了大概，具体论文没看，好像是从强化学习中的 AutoAugment 衍生而来的）。不同任务的效果如下所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519193829228.png" alt="image-20230519193829228"></p><h2 id="训练技巧（Tricks）"><a href="#训练技巧（Tricks）" class="headerlink" title="训练技巧（Tricks）"></a>训练技巧（Tricks）</h2><h3 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h3><ol><li><p>基于置信度的掩码（Confidence-based masking）</p><p>对预测效果不好的样本（指针对一致性预测的原始样本），即置信度（最大的样本的概率）小于一定阈值数据，不计入一致性损失。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519194350155.png" alt="image-20230519194350155"></p></li><li><p>输出分布锐化（Sharpening Predictions）</p><p>降低预测结果的熵对训练有好处，所以作者对无标签的预测见过做<u><strong>锐化</strong></u>，采用的方法为 <u><strong>low Softmax temperature τ</strong></u>，与方法一相结合，在 batch 大小为 B 的情况下，损失为：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519194803301.png" alt="image-20230519194803301"></p></li><li><p>域外相关数据的选择（Domain-relevance Data Filtering）</p><p>无标签数据量大，其中的数据分布往往是不均衡且有大量任务无关数据，为了解决这个问题，论文提出一种通用的无标签数据分布均衡化策略。首先利用有标签数据训练一个初始化模型，然后去预测所有无标签数据，根据置信度均衡选择各类别数据。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519194958974.png" alt="image-20230519194958974"></p></li></ol><h3 id="训练层面"><a href="#训练层面" class="headerlink" title="训练层面"></a>训练层面</h3><p>Training Signal Annealing（训练信号退火）</p><p>主要是针对标签数据与未标签数据不平衡时的场景，由于有大量的未标签数据需要UDA 处理，所以需要一个较大模型，但是由于较大模型很容易在少量标签数据下过拟合，所以，提出了本方法用于解决该问题。</p><p>基本原理就是在训练过程中，随着未标签数据的增加，逐步去除带标签数据，从而避免模型过拟合到带标签的训练数据。具体而言，就是在训练的 <code>t</code> 时刻，设置一个阈值 <code>ηt</code>，当 <code>1/K ≤ ηt ≤ 1</code>，其中，<code>K</code> 是类别数，当某个标签数据计算的 <code>p_θ(y∗| x)</code>大于阈值<code>ηt</code>，将该标签数据移除出计算损失的过程，而只计算 miniBatch 里面的其余数据。</p><p>具体策略有 3 种：</p><ul><li>log-schedule</li><li>linear-schedule</li><li>exp-schedule</li></ul><p>对于 labeled 数据量少，容易过拟合情况，选择最后一种；对于 labeled 数据量较多，过拟合不严重，可视情况选择前两种。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230519195814680.png" alt="image-20230519195814680"></p><h2 id="理论方面的探讨（Theoretical-Analysis）"><a href="#理论方面的探讨（Theoretical-Analysis）" class="headerlink" title="理论方面的探讨（Theoretical Analysis）"></a>理论方面的探讨（Theoretical Analysis）</h2><blockquote><p>理论渣渣只能意会不可用文字整理出来，具体看论文吧…</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>给人的感觉这一篇好“工程”😂，在数据方面做了很多文章，但半监督领域又好像都是在对数据这一方面做很多“动作”，不管了，接着看，接着读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Unsupervised Data Augmentation for Consistency Training&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会议：NeurIPS 2019&lt;/p&gt;
&lt;p&gt;论文地址：&lt;a href=&quot;https://ar</summary>
      
    
    
    
    <category term="半监督学习" scheme="https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Semi-Surprised-Learning" scheme="https://ytz7.github.io/tags/Semi-Surprised-Learning/"/>
    
    <category term="Data Augmentation" scheme="https://ytz7.github.io/tags/Data-Augmentation/"/>
    
  </entry>
  
  <entry>
    <title>Virtual Adversarial Training</title>
    <link href="https://ytz7.github.io/posts/cc87ae2e.html"/>
    <id>https://ytz7.github.io/posts/cc87ae2e.html</id>
    <published>2023-05-17T11:50:25.000Z</published>
    <updated>2023-05-21T12:08:10.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A Regularization Method for Supervised and Semi-Supervised Learning</p></blockquote><p>期刊：IEEE Transactions on Pattern Analysis and Machine Intelligence (2018)</p><p>论文地址：<a href="https://arxiv.org/abs/1704.03976"> Virtual Adversarial Training</a></p><p>Pytorch 复现：<a href="https://github.com/sndnyang/vat_pytorch">sndnyang/vat_pytorch</a></p><p>参考文章：</p><ul><li><a href="https://amitness.com/2020/07/semi-supervised-learning/">Semi-Supervised Learning in Computer Vision</a></li><li><a href="https://blog.csdn.net/by6671715/article/details/122723657"> 码侯烧酒的博客</a></li><li><a href="https://facico.blog.csdn.net/article/details/114634056?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-114634056-blog-119420855.235%5Ev36%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-114634056-blog-119420855.235%5Ev36%5Epc_relevant_default_base&amp;utm_relevant_index=1">Facico的博客</a></li></ul><p>参考视频：</p><ul><li><a href="https://www.bilibili.com/video/BV1j64y1v7p4?p=1&amp;vd_source=7801e0201bc8ddcb3d951c7388a08c3e">数最后一名</a></li></ul><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>论文的关键想法同样保持着<u><strong>一致性正则化</strong></u>的思想，只不过将图像的增强方式以生成<u><strong>对抗样本（Adversarial Example）</strong></u>来代替之，有标签的损失采用<u><strong>交叉熵（Cross-Entropy）</strong></u>计算，无标签的损失使用 <u><strong>KL 散度（KL Divergence）</strong></u>来计算，最后施以对应的权重得到最终的损失，大致流程图如下所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230517202628300.png" alt="image-20230517202628300"></p><h2 id="一致性正则化"><a href="#一致性正则化" class="headerlink" title="一致性正则化"></a>一致性正则化</h2><p>具体来说，基于平滑假设和聚类假设，具有不同标签的数据点在低密度区域分离，并且相似的数据点具有相似的输出。如果对一个未标记的数据应用实际的扰动，其预测结果不应该发生显著变化，也就是输出具有一致性。其数学表达如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230517203120942.png" alt="image-20230517203120942"></p><p>其中，<code>D</code> 为度量函数，一般采用 <code>KL 散度</code> 或者 <code>JS 散度</code>，当然也可以使用交叉熵或者平方误差等，<code>Augment(·)</code> 是指数据增强函数，当采用数据增强是，视为对样本/模型添加一些噪声扰动，<code>θ</code> 为模型参数。</p><p>常见的数据增强有以下：</p><ul><li>常规的数据增强：平移旋转，随机 dropout等</li><li>时序移动平均：Temporal Ensembling，Mean-Teacher 中使用的方法</li><li>对抗样本扰动：VAT</li><li>高级数据增强：<a href="https://arxiv.org/abs/1904.12848v2">UDA</a></li></ul><h2 id="对抗训练"><a href="#对抗训练" class="headerlink" title="对抗训练"></a>对抗训练</h2><p>对抗训练（Adversarial Training）是增强神经网络鲁棒性的重要方式，在对抗训练的过程中，样本会被混合一些微小的扰动（哪怕改变很小，但很有可能会造成错误分类），使神经网络适应这种改变，从而对对抗样本具有鲁棒性。</p><p>生成对抗样本有以下几种常见方式：</p><ul><li><p>基于梯度法: <a href="https://arxiv.org/abs/1412.6572">Explaining and Harnessing Adversarial Examples</a></p></li><li><p>基于超平面分类: <a href="https://arxiv.org/abs/1511.04599">DeepFool: a simple and accurate method to fool deep neural networks</a></p></li><li><p>对抗攻击（Adversarial Attack）：在模型原始输入上添加对抗扰动</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/2020101817001880.png" alt="img"></p></li></ul><p>Goodfellow 对对抗训练损失函数定义如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230517204302784.png" alt="image-20230517204302784"></p><p>其中，<code>D</code> 是衡量两个分布相似度的函数，<code>q(y|xl)</code> 是样本的真实分布，<code>p(y|xl, θ)</code> 是由参数和 <code>xl</code> 生成的预测分布，通过增加扰动 <code>radv</code> 来使得两个分布尽量相似。</p><p>对抗为什么可行？</p><ul><li>因为很多网络被设计得十分“线性”，像 LSTM 这样的，对x的每个维度都做微小扰动，当x的维度变大的时候，会对网络造成较大的影响</li><li>网络的线性，使得高阶导近似0，Taylor 展开后占主导的是线性的部分，所以用来干扰的主要就是对抗样本中线性的部分</li></ul><p>通常，我们无法获得精确对抗性扰动的<u><strong>闭式解</strong></u>，不过可以通过上式中的度量 D 来线性近似 r，使用 <code>L2</code> 正则是，对抗扰动可以通过下面的式子近似：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230517205056447.png" alt="image-20230517205056447"></p><p>使用 <code>L∞</code> 正则时，可通过下面的式子近似：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230517205330497.png" alt="image-20230517205330497"></p><p>其中 <code>g</code> 为：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230517205353604.png" alt="image-20230517205353604"></p><p>可通过<u><strong>反向传播</strong></u>进行计算，对抗方法得到的扰动方向，比随机找一个扰动更好。</p><p>对抗训练存在的缺点：仅仅只能适配于有监督学习，当样本没有标签就不能进行，故作者提出了一种可以运用于<u><strong>半监督学习</strong></u>的对抗训练方法。</p><h2 id="Virtual-Adversarial-Training-VAT"><a href="#Virtual-Adversarial-Training-VAT" class="headerlink" title="Virtual Adversarial Training, VAT"></a>Virtual Adversarial Training, VAT</h2><p>Adversarial Direction，对抗性方向，其概念是指能够最大程度减少准确分类的概率的方向，如下图所示，寻找扰动项 <code>radv</code>，其投影点与准确分类的方向为对抗性方向。</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/1684329811138.png" alt="1684329811138" style="zoom: 50%;"><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230517212606646.png" alt="image-20230517212606646"></p><p>local distributional smoothness（LDS），定义为衡量当前基于每个输入数据的模型的平滑度的负函数。</p><h3 id="推导流程"><a href="#推导流程" class="headerlink" title="推导流程"></a>推导流程</h3><blockquote><p>由于不知道为什么公式渲染不出来，我就不手打公式了，等有时间再去把这个问题弄了，我就直接套用现成已有的公式，或是直接手写出来，Sorry…</p></blockquote><p>文中的符号定义如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518145424158.png" alt="image-20230518145424158"></p><p>在上面，我们提到，<u><strong>对抗训练</strong></u>只适用于带标签的有监督问题，在半监督学习中并不是很适用，所以，作者就提出了<u><strong>虚拟对抗训练</strong></u>，<code>VAT</code> 的损失函数如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518145654097.png" alt="image-20230518145654097"></p><p>其中，<code>x⁎</code>可以表示为有标签或者无标签数据，正如上文中所提到的，在实际中，并没有关于 <code>q(y, xul)</code> 的直接信息，因此可以使用<code>p(y|x, θ)</code>来替换之，如果带标签的样本比较多时，<code>p</code>就会逼近<code>q</code>，利用<code>p</code>生成的虚拟标签代替不知道的标签，并根据虚拟标签计算对抗方向，此时的虚拟标签是用上一步训练之后得到的模型进行估计，故损失函数更新如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518150409362.png" alt="image-20230518150409362"></p><p>将损失函数求平均，得到正则项（<strong>regularization term</strong>）：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518150651440.png" alt="image-20230518150651440"></p><p>完整的目标函数为：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518150735667.png" alt="image-20230518150735667"></p><p>其中第一项为<u><strong>带标签数据的负对数似然函数</strong></u>（针对有标签数据），VAT 的一个优点是：只有两个超参数：（1）对抗方向的限制参数（norm constraint）<code>ɛ &gt; 0</code>；（2）控制目标函数的两个目标项的相对平衡的正则化系数（regularization coefficient）<code>α &gt; 0</code>，事实上，作者指出，两个超参数的作用大抵相同，于是 VAT 中只微调了超参数 <code>ɛ</code>，而将 <code>α</code> 固定为 1。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518151554425.png" alt="image-20230518151554425"></p><p>对于上述目标函数，观察到，当 r = 0 时，D 永远为 0，所以需要对 D 进行二阶泰勒展开，这里的 D 为：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518151854028.png" alt="image-20230518151854028"></p><p>二阶展开后得到：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518151914984.png" alt="image-20230518151914984"></p><p>其中 H 为海森矩阵（Hessian Matrix），具体如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518152200457.png" alt="image-20230518152200457"></p><p>故 <code>rvadv</code> 可以近似为：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518152332268.png" alt="image-20230518152332268"></p><p>其中：u 是 H 的第一特征主向量，上划线表示同方向单位向量（算了我写出来.）</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/1684394786562.png" alt="1684394786562"></p><p>在计算 H 的特征值/特征向量时，时间复杂度需要 <code>O(I³)</code>，论文中提到使用幂迭代法（ power iteration method）和有限差分法（finite difference method）来近似求解，假设 <code>d</code> 为与特征向量不垂直的一个随机单位向量，迭代计算如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518153132095.png" alt="image-20230518153132095"></p><p>注意到 <code>Hd</code> 可以被有限差分来近似计算：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518153216356.png" alt="image-20230518153216356"></p><p>由于 D 的一介导还是很可能为 0，所以 r 用如下方式迭代更新：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518153419621.png" alt="image-20230518153419621"></p><p><u><strong>迭代的次数越多效果越好</strong></u>，甚至很多数据集上迭代次数为 1 都取得了较好的效果，迭代次数如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518153804154.png" alt="image-20230518153804154"></p><p>伪代码如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518153918543.png" alt="image-20230518153918543"></p><p>效果如下所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518154205948.png" alt="image-20230518154205948"></p><p>迭代次数较少的情况下，有大量的<u><strong>未标记点（灰色点）</strong></u>会有较高的<u><strong>LDS（深蓝色）</strong></u>，即不平滑，因为模型一开始对相同类别的 point 预测了不同的 label，VAT 会让 LDS 较高的数据点更大的压力，使得数据点间边界更平滑。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文章的亮点就是对于二阶导以及之后的各种近似优化，理论方面很充足，实验也很充足，理论方面对于我这个渣硕来说真的挺艰难，我在去年 12 月份就准备看这一篇，结果因为理论被劝退，终于时隔数月，我算是啃下来了…不过也还是云里雾里的，还是得补充一下数学理论知识啊，果然我导说的没错，理论知识都不懂，给我发论文看我都看不懂，那还搞啥呢，哈哈🤦‍♂️，就这样子，如果有机会再复盘这篇论文，有问题在更新。</p><p>最后附上我得手写版公式（惨不忍睹的被公式薄纱了）：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518155255116.png" alt="image-20230518155255116"></p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518155319698.png" alt="image-20230518155319698"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;A Regularization Method for Supervised and Semi-Supervised Learning&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;期刊：IEEE Transactions on Pattern Ana</summary>
      
    
    
    
    <category term="半监督学习" scheme="https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Semi-Surprised-Learning" scheme="https://ytz7.github.io/tags/Semi-Surprised-Learning/"/>
    
    <category term="Adversarial Example" scheme="https://ytz7.github.io/tags/Adversarial-Example/"/>
    
  </entry>
  
  <entry>
    <title>关于深度学习中遇到的知识盲区</title>
    <link href="https://ytz7.github.io/posts/eaa3f406.html"/>
    <id>https://ytz7.github.io/posts/eaa3f406.html</id>
    <published>2023-05-11T11:47:01.000Z</published>
    <updated>2023-05-21T12:08:10.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于深度学习的一些问题与知识盲区"><a href="#关于深度学习的一些问题与知识盲区" class="headerlink" title="关于深度学习的一些问题与知识盲区"></a>关于深度学习的一些问题与知识盲区</h1><p>此篇用于记录在阅读论文以及博客时遇到的一些问题和知识盲区，方便日后进行复盘。</p><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><h3 id="为什么需要激活函数？"><a href="#为什么需要激活函数？" class="headerlink" title="为什么需要激活函数？"></a><strong>为什么需要激活函数？</strong></h3><p>通常激活函数都是非线性的，它能够帮助我们引入非线性因素，使得神经网络能够更好地解决更加复杂地问题，在简单的二分类问题中，如果不使用激活函数，使用简单的**<u>逻辑回归</u>**，那么该模型只能作简单的线性分类，而不能作复杂的非线性划分，如下图所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230511195806300.png" alt="image-20230511195806300"></p><p>值得一提的是，如果所有的隐藏层全部使用线性激活函数，只有输出层使用非线性激活函数，那么整个神经网络的结构就类似于一个简单的逻辑回归模型，效果与单个神经元无异。另外，如果是拟合问题而不是分类问题，输出层的激活函数可以使用线性函数。</p><h3 id="Sigmoid-函数饱和带来的问题"><a href="#Sigmoid-函数饱和带来的问题" class="headerlink" title="Sigmoid 函数饱和带来的问题"></a>Sigmoid 函数饱和带来的问题</h3><p>Sigmoid 函数的取值范围在 (0,1) 之间，单调连续，求导容易，一般用于二分类神经网络的输出层。</p><p>Sigmoid 函数饱和区范围广，容易造成梯度消失。饱和区如下图所示，图中红色椭圆标注的饱和区曲线平缓，梯度的值很小，近似为零，且 Sigmoid 函数的饱和区范围很广，除了 [-5,5]，其余区域都可以认为是饱和区，这种情况很容易造成梯度消失，梯度消失会增大神经网络训练难度，影响神经网络模型的性能。</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230511200333796.png" alt="image-20230511200333796" style="zoom:50%;"><h2 id="降噪自编码器-Denoising-Auto-Encoder"><a href="#降噪自编码器-Denoising-Auto-Encoder" class="headerlink" title="降噪自编码器 Denoising Auto-Encoder"></a>降噪自编码器 Denoising Auto-Encoder</h2><p>在神经网络模型训练阶段开始前，通过 Auto-encoder 对模型进行预训练可确定编码器 W 的初始参数值。然而，受模型复杂度、训练集数据量以及数据噪音等问题的影响，通过 Auto-encoder 得到的初始模型往往存在过拟合的风险。</p><p>简单理解，在人类的感知过程中，某些模态的信息对结果的判断影响并不大。举个例子，一块圆形的饼干和一块方形的饼干，在认知中同属于饼干这一类，因此形状对我们判断是否是饼干没有太大作用，也就是<strong>噪声</strong>。如果不能将形状数据去除掉，可能会产生“圆饼干是饼干，方饼干就不是饼干”的问题（过拟合）。</p><p>当采用无监督的方法分层预训练深度网络的权值时，为了学习到较鲁棒的特征，可以**<u>在网络的可视层（即数据的输入层）引入随机噪声</u>**，这种方法称为降噪自编码器（<a href="https://dl.acm.org/doi/abs/10.1145/1390156.1390294">Denoising Auto-Encoder， DAE</a>）。</p><blockquote><p>降噪自编码器：一个模型，能够从有噪音的原始数据作为输入，而能够恢复出真正的原始数据。这样的模型，更具有鲁棒性。</p></blockquote><p>以下是以经典的 MNIST 手写数字识别为例，对于输入的数据引入了变换角度、随机噪点、添加背景图像等噪音。模型通过训练后可以对有噪音图像更加鲁棒，而这也更符合实际使用的需求。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/v2-2b0c0b5855f0c98b44fbeaf75d6a72dd_r.jpg" alt="img"></p><p>对于有噪音的输入数据，区别于一般自编码机，降噪自编码机要做的就是数据的降噪。关于降噪的过程如下图所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/v2-9ab89078a4630eb52347244a61410c2f_r.jpg" alt="img"></p><p>对于输入层 $x$，以一定概率将其节点置 0，得到 $\hat{x}$,用 $\hat{x}$ 去计算 $y$,计算 $z$ ，并将 $z$ 与原始 $x$ 做误差迭代，对结果误差较小的节点可以认为是噪声。每层处理重复上述工作。</p><p>自编码器的本质是学习一个相等函数，即网络的输入和重构后的输出相等，这种相等函数的表示有个缺点就是当测试样本和训练样本不符合同一分布，效果不好，而降噪自编码器在这方面的处理有所进步。</p><h2 id="随机深度-Stochastic-Depth"><a href="#随机深度-Stochastic-Depth" class="headerlink" title="随机深度 Stochastic Depth"></a>随机深度 Stochastic Depth</h2><p>针对于残差模块的优化，由于很深的 ResNet 通常需要很长时间的训练(也就是训练很慢)，作者引入了一种类似于 dropout 的方法，在训练过程中随机丢弃子图层（randomly drop a subset of layers），而在推断时正常使用完整的图。</p><p>ResNet 网络是由一个接一个的残差模块(ResBlock)串联起来的，可以视为ResBlock的集合。在训练时，对每个 ResBlock 随机 drop（按伯努利分布），drop 就是将上一个 ResBlock 直接输出到下一个 ResBlock，被 drop 的 ResBlock 什么都不做也不更新。另外，网络的输入被视为第一层，是不会 drop 的。</p><p>与 Dropout 的不同之处在于，该方法 drop 整个 ResBlock，而 Dropout 在训练期间只 drop 一部分神经元节点。这种方法大大降低了训练时间，甚至在训练完成后删除部分layer，还能不影响精度。</p><h2 id="最小化信息熵-Entropy-Minimization"><a href="#最小化信息熵-Entropy-Minimization" class="headerlink" title="最小化信息熵 Entropy Minimization"></a>最小化信息熵 Entropy Minimization</h2><p>参考文章：<a href="https://kexue.fm/archives/5448">最小熵原理（一）</a></p><p>在半监督学习中，有标签（分类完全准确）的数据样本通常相对较少，通过训练模型对未标记数据样本进行预测，选择出高置信度的样本，作为标记样本同有标签样本作为下一次训练的数据样本。</p><p><u><strong>Entropy Minimization</strong></u> 是一种在半监督学习中使用的技术，它的目的是最小化信息熵，从而使模型在分类时的不确定性最小。在半监督学习中，我们希望模型尽可能地利用未标记数据来学习，但是这些数据并不带有正确的标签，因此我们需要利用某些技术来帮助我们学习这些数据。</p><p><u><strong>加快模型学习进度的唯一方法就是降低学习目标的冗余信息量</strong></u>，所提到的“去冗余”，可以理解为“省去没必要的学习成本”。</p><p>也就是通常所使用到的技巧：过滤掉低置信度的未标记样本，保留高置信度样本。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230512164646319.png" alt="image-20230512164646319"></p><h2 id="Top-1-and-Top-5-Accuracy"><a href="#Top-1-and-Top-5-Accuracy" class="headerlink" title="Top-1 and Top-5 Accuracy"></a>Top-1 and Top-5 Accuracy</h2><p>Top-1：</p><p>在多分类问题中，一般认为在经过全连接层后得到的概率分布中概率最大的类别为我们模型的预测类别，就判断为正确。</p><p>Top-5：</p><p>在多分类问题中，一般认为在经过全连接层后得到的概率分布中概率最大的全五个类别中有我们模型的预测类别，就判断为正确。</p><h2 id="Dark-Knowledge"><a href="#Dark-Knowledge" class="headerlink" title="Dark Knowledge"></a>Dark Knowledge</h2><p>可以看作是经过 Softmax 函数后得到的各类类别的可能性，其包含着类别之间的相关性，比如，猫和狗的相似性，要远远大于猫和船的相似性，而这种相似性，会在概率值中有所体现，而这部分信息一致没有被很好的利用，所以称之为 Dark Knowledge。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于深度学习的一些问题与知识盲区&quot;&gt;&lt;a href=&quot;#关于深度学习的一些问题与知识盲区&quot; class=&quot;headerlink&quot; title=&quot;关于深度学习的一些问题与知识盲区&quot;&gt;&lt;/a&gt;关于深度学习的一些问题与知识盲区&lt;/h1&gt;&lt;p&gt;此篇用于记录在阅读论文以及博</summary>
      
    
    
    
    <category term="深度学习" scheme="https://ytz7.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://ytz7.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>半监督学习学习过程</title>
    <link href="https://ytz7.github.io/posts/52ee1a8c.html"/>
    <id>https://ytz7.github.io/posts/52ee1a8c.html</id>
    <published>2023-05-11T07:08:40.000Z</published>
    <updated>2023-05-21T12:08:10.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>学习了快一个学期的 Java 程序开发，让我感觉开发的过程真的好空洞…但是我并不知道下一步到底要做什么，又处于想找实习又怕找不到的情况下，刷了几天 LeetCode，然后又变成了“小🐏人”，紧接着被隔离😅，真的挺痛苦，所幸在第三天就“出狱”了，在蹲“监狱”期间，受到一个“狱友”的启发，“还是要做好职业规划的，若是没有做好职业规划，像一只无头苍蝇一样，很可能在毕业之际还是找不到工作。”在思考了一天后，我决定重新开始在“半监督学习”这个领域开始零基础学习了，为什么会有这个想法？是因为我觉得我起初考研的目的是为了能够在人工智能这个领域继续深入了解，目的很单纯，那为什么我不坚持一下呢？于是我决定重新开始这个计划，管他呢，起码是自己喜欢做的事情，哪怕未来找不到工作什么的，起码现在是由试错的资本的。</p><p>以下将会记录我在学习时候遇到的问题/解决方式/新思路/感想。</p><h2 id="Self-Training"><a href="#Self-Training" class="headerlink" title="Self-Training"></a>Self-Training</h2><p>自训练方法，模型基于已标记好的训练集进行训练，得到一个基础模型，利用该基础模型对未标记的数据集进行预测一个<strong>伪标签</strong>，然后将两个数据集整合训练，得到一个新的模型，从而迭代更新模型参数，生成一个最优模型。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230511161304502.png" alt="image-20230511161304502"></p><h3 id="Pseudo-Label"><a href="#Pseudo-Label" class="headerlink" title="Pseudo-Label"></a><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.664.3543&amp;rep=rep1&amp;type=pdf">Pseudo-Label</a></h3><p>伪标签技术适用于小样本学习，实际上在样本极其珍贵的金融、医疗图像、安全等领域，伪标签学习有时候很有效。</p><p>伪标签的定义来自于半监督学习，半监督学习的核心思想是<u><strong>通过借助无标签的数据来提升有监督过程中的模型性能</strong></u>。</p><p>粗略来讲，伪标签技术就是<u><strong>利用在已标注数据所训练的模型在未标注的数据上进行预测，根据预测结果对样本进行筛选，再次输入模型中进行训练的一个过程</strong></u>。</p><p>如下图所示，利用有标签的数据集训练出一个模型，运用训练出的模型给予无标签数据一个<u><strong>伪标签</strong></u>。如何定义所属类别？利用训练好的模型对无标签数据进行预测，以概率最高的类别作为无标签数据的伪标签。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230511161425308.png" alt="image-20230511161425308"></p><blockquote><p>entropy regularization：用于防止模型过拟合，通过在损失函数中加入熵（entropy）项来实现</p></blockquote><p>利用 <em>entropy regularization</em> 思想，将无监督数据转为目标数据的正则项，即将拥有伪标签的无标签数据视为有标签的数据，利用交叉熵（与最初训练模型一致）来评估误差大小。</p><p>模型整体的目标函数如下：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/v2-103a30551a86aa99222f8f35129088d7_r.jpg" alt="img"></p><p>其中左边一项为交叉熵，用来评估有标签数据的误差，右边一项即为 <em>entropy regularization</em> 项，用来从无标签的数据中获取训练信号。</p><p>为了平衡有标签数据和无标签数据的信号强度，如上所示，算法在目标函数中引入了时变参数 α(t)，其数学形式如下，其中 T1 和 T2 都为超参数：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/v2-4d5a8a1d8aa4b9037859ab19dd346c0b_r.jpg" alt="img"></p><p>因此，随着训练时间的增加，α(t) 将会从零开始线性增长至某个饱和值，对应无标签数据的信号也将逐渐释放出来。背后的核心想法也很直观，早期模型预测效果不佳，因此 <em>entropy regularization</em> 产生信号的误差也较大，因而 α(t) 应该从零开始，由小逐渐增大。</p><p><strong>存在不足：</strong>只在训练时间这个维度上，采用了退火思想，即采用时变系数α(t)。而在伪标签这个维度，对于模型给予的预测标签一视同仁，这种方法在实际中存在明显问题。若模型在对伪标签的数据预测后， 10 个类别预测概率值都接近于 0.1，以最大概率这一原则选择对应的标签，那么这个标签对模型的训练会造成一定的<u><strong>副作用</strong></u>。</p><p><strong>设想如何突破这一不足？</strong></p><p>也许可以设定一个阈值，抛弃那些预测最大概率值小于该阈值的未标记样本，将满足条件的未标记样本分配伪标签，并加入模型评估当中，之后再迭代训练。</p><h3 id="Noisy-Student"><a href="#Noisy-Student" class="headerlink" title="Noisy Student"></a><a href="https://arxiv.org/abs/1911.04252">Noisy Student</a></h3><p>论文的关键 idea 是训练两个模型，“teacher”和“student”，强调的是在student模型中加入噪声，teacher 模型和 student 模型可以用不同的模型训练，也可以使用相同的模型。</p><p>在有标签数据中训练“teacher”模型，并利用该模型对未标记数据进行推断伪标签，这些伪标签可以是<u><strong>软标签</strong></u>，也可以取其最大概率的类别将其转换为<u><strong>硬标签</strong></u>。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230511161507462.png" alt="image-20230511161507462"></p><p>然后将标记数据与为标记数据（带有伪标签）置入“student”进行训练，在训练之前<u><strong>数据增强</strong></u>使用 <strong>RandAugment</strong>，待“student”模型训练好后，使用最新的模型作为新的“teacher”，进行下一次迭代，此过程会重复几次（通常为 3 次）。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230511211613877.png" alt="image-20230511211613877"></p><p>总结该篇论文的流程思路：</p><ol><li>首先将在 ImageNet 上训练好的模型作为 Teacher Network 来训练 Student Network</li><li>再使用训练好的 T 网络（无噪音）来对另一个数据集 [JFT dataset] 生成尽可能准确的伪标签</li><li>之后使用生成伪标签的数据集 [JFT dataset] 和 ImageNet 一起训练 Student Network</li><li>Student Network中增加了模型噪音<ul><li>Dropout</li><li>随机深度  Stochastic Depth</li><li>数据噪音：对图片进行数据增广（RandAugment）</li></ul></li></ol><p>对 Student 模型添加噪音的作用：</p><ol><li><strong>数据噪音</strong>：提高泛化能力</li><li><strong>模型噪音</strong>：提高模型鲁棒性和泛化能力</li></ol><p>具体参数设置：</p><ol><li><strong>Stochastic Depth</strong>：幸存概率因子为 0.8</li><li><strong>Dropout</strong>：分类层（final layer）引入 0.5 的丢弃率</li><li><strong>RandAugment</strong>：应用两个随机计算，其震级设置为 27</li></ol><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230512204307583.png" alt="image-20230512204307583"></p><p>其他 Tricks：</p><ol><li><strong>数据过滤</strong>：将教师模型中置信度不高的图片过滤，因为这通常代表着域外图像（out-of-domain data）</li><li><strong>数据平衡</strong>：平衡不同类别的图片数量，当一个类别所对应的图片数量不是很充足时，会采取<u>随机复制</u>的方法来扩充样本量</li><li><strong>软标签（Soft Pseudo-Label）</strong>：在消融实验中表示，软标签对域外图像有更强的指导作用</li></ol><h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p>1.噪音是否对模型有影响？（The Importance of Noise in Self-training）</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230512205434466.png" alt="image-20230512205434466" style="zoom:80%;"><p>从结果可以看出，<u>噪音</u>、<u>随机深度</u>、<u>数据扩充</u>起着重要的作用使学生模型胜过教师模型，对此有人提出是不是对未标记数据加入正则项以防止过拟合来代替噪音，作者在实验中说明这是不对的。因为在去噪的情况下，未标记图像的训练损失并没有下降多少以此说明模型并没有对未标记数据过拟合。</p><p>2.对于迭代训练的消融实验（A Study of Iterative Training）</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230512205650571.png" alt="image-20230512205650571" style="zoom:80%;"><p>作者先在<u><strong>标记数据</strong></u>上训练了 EfficientNet-B7 作为 Teacher，然后再训练 EfficientNet-L2 作为 Student，然后让 Student 作为 Teacher 依次迭代三轮，作者表明，迭代训练提高了准确度，并且，给出再最后通过调整未标记图像和标记图像的比为 <strong>1 : 28</strong> 时达到最优 Top-1 Acc.。</p><p>3.能力强的教师模型会不会对学生模型造成的影响</p><p>4.无标签的数据量大小</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230512210409208.png" alt="image-20230512210409208" style="zoom:80%;"><p>作者按照比例分别从整个数据集中<u><strong>均匀采样（uniformly sampling）</strong></u>，会发现在数据量减少至 1/16 中，模型的性能大都相似，在数据量达到 1/32 或更小后，模型性能有了显著的下降（可能 .3 个点就可以算是显著的下降了吧…），所以，使用大量未标记的数据会产生更好的性能，但作者指出：<u>对于大模型来说，数据量越多越好，而小模型由于容量限制则很容易饱和</u>。</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230512210908139.png" alt="image-20230512210908139" style="zoom:80%;"><p>5.硬标签和软标签对域外图像的影响</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230512210946955.png" alt="image-20230512210946955" style="zoom:80%;"><p>作者将预测置信度高（high-confidence）的图像视作域内图像（in-domain images），反之，将预测置信度低（low-confidence）的图像视作域外图像（out-of-domain images），作者表明：对于域内图像，软伪标签（ soft pseudo labels）和硬伪标签（hard pseudo labels）都对模型有一定的帮助；而对于域外图像，软伪标签使得模型对域外图像的判断有着一定的帮助，而硬标签则会对模型的精度有一定的损害。</p><p>剩下的<u><strong>消融实验</strong></u>就不写了，有点过于冗长了。</p><h2 id="Consistency-Regularization"><a href="#Consistency-Regularization" class="headerlink" title="Consistency Regularization"></a>Consistency Regularization</h2><p>说到一致（Consistency），其实很多代价都有这个内涵，如 MSE 代价，最小化预测与标签的差值，也就是希望预测与标签能够一致。其他的代价，如 KL 散度、交叉熵代价也类似。</p><p>所以一致性，是一种非常内在而本质的目标，可以让深度网络进行有效学习。 </p><p>在半监督领域中，未标记数据没有标签，所以需要让模型有个参照，从而通过这个参照从未标记数据中学习。</p><p><strong>Consistency Regularization</strong> 的主要思想是：相同的一张图片，通过模型所预测出来的结果应该是一样的。对于未标记样本，虽然没有对应的标签来使得模型判断预测结果是否准确，但是，却可以在原有的样本中添加一定的噪声，让模型通过比对预测结果来进行学习。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515151137355.png" alt="image-20230515151137355"></p><h3 id="π-model-and-Temporal-Ensembling"><a href="#π-model-and-Temporal-Ensembling" class="headerlink" title="π-model and Temporal Ensembling"></a>π-model and Temporal Ensembling</h3><p>论文地址：<a href="https://arxiv.org/abs/1610.02242">Temporal Ensembling for Semi-Supervised Learning</a> </p><h4 id="π-model"><a href="#π-model" class="headerlink" title="π-model"></a>π-model</h4><p>如下图所示，一个有标签样本（可视作无标签样本），经过随机图像增强输入网络，同时网络也会进行 Dropout 也可以视作噪声，输入两次得到两个结果 Z 和 Z’，将 Z 与图片真正标签 y 进行比对，使用 <code>交叉熵（cross-entropy）</code>计算损失 L1；将 Z 与 Z’ 使用 <code>平方差（squared difference）</code>计算损失 L2，然后将两个过程所得到的损失相加，但需要注意的是，两个损失分别占有一定权重，且占有的权重值会随着训练时间改变，在图 2 的所标记的损失函数公式可以看出。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515154058143.png" alt="image-20230515154058143"></p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515160459380.png" alt="image-20230515160459380"></p><p>其中 C 表示标记样本的的全部类别数量，w(t) 是随时间变化的加权函数，</p><p>并且，作者指出，第一部分的损失只针对有标签数据进行计算，而第二部分的损失则针对所有数据进行计算，即在算损失的时候，有标签数据两个损失项都用，无标签数据只用第二个损失项：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515161927609.png" alt="image-20230515161927609"></p><p>作者指出，使用 w(t) 时，由于前期模型差不多被有监督损失部分（标记数据样本）所支配，所以，在增长的前期，使权重增长的尽可能慢一点。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515163443077.png" alt="image-20230515163443077"></p><p>总结流程就是，数据集：有标签/无标签图片，分别两次输入模型，其中，L1只在有标签数据参与训练的过程中用于计算损失，L2 则是都有参与计算损失（有标签和无标签）。模型的噪音来自于：输入图像的随机增强，以及模型训练过程中的 Dropout。计算损失公式：L1 使用<u><strong>交叉熵</strong></u>来计算损失，L2 使用<u><strong>平方差公式</strong></u>来计算损失。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516131038965.png" alt="image-20230516131038965"></p><h4 id="Temporal-Ensembling"><a href="#Temporal-Ensembling" class="headerlink" title="Temporal Ensembling"></a>Temporal Ensembling</h4><p>由于以这种方式获得的培训目标是基于对网络的单一评估，因此可以预期它们会很嘈杂。暂时性结合通过将多个先前网络评估的预测汇总为整体预测来减轻这种情况</p><p>在 π-model 中，模型的训练结果都只是对网络进行单一评估，预测结果没有很强的关联性，这样子就造成了模型变得很“嘈杂”，并且，直觉认为，很难不相信过去预测结果与现在的预测结果不存在联系，这就是 π-model 的缺点。</p><p>在 Temporal Ensembling 中就很好的解决了这一个问题，在计算第二部分的损失中，生成的 Z’ 要参与下一个 epoch 的损失计算，（注意是每一个 epoch，而不是每一个 batch，这种改变其实是非常缓慢）。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515154108557.png" alt="image-20230515154108557"></p><p>每训练完一个 epoch 后，就会将 Z 进行更新：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515165329913.png" alt="image-20230515165329913"></p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230515154426776.png" alt="image-20230515154426776"></p><p>总结流程，不同于 π-model，Temporal Ensembling 只进行一次模型预测，π-model 中的第二次训练预测，前一个 epoch 保存下来的 Z 与当前 epoch 的 z 进行指数滑动平均（Exponential Moving Average，EMA）运算得到，其中 z’ 是当前 epoch 的模型预测，参与 L2 的损失计算。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516132020990.png" alt="image-20230516132020990"></p><h3 id="Mean-Teacher"><a href="#Mean-Teacher" class="headerlink" title="Mean Teacher"></a><a href="https://arxiv.org/abs/1703.01780">Mean Teacher</a></h3><p>论文的关键思想是使用两个模型一个叫做<code>Student</code>，另一个叫做<code>Teacher</code>，其中Student 模型是一个带有 <u><strong>Dropout</strong></u> 的标准网络模型，与上文中所提到的 <u><strong>Noise Student</strong></u> 不同的是，该篇论文中的 Teacher 模型的架构与 Student 模型一致，且更新参数时是由 Student 模型的参数作<u><strong>指数滑动平均</strong></u>计算得到。计算损失的方式与 <u><strong>Temporal Ensembling</strong></u>相似/一致，有标签数据使用两个损失项，而无标签数据使用 Student 和 Teacher 模型得到的结果计算一致性损失，最后模型的总损失是由两个部分的损失得到。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516162131724.png" alt="image-20230516162131724"></p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516165459330.png" alt="image-20230516165459330"></p><p>使用指数滑动平均来更新参数后，模型可以在每一个 step 而不是在每一个 epoch来聚合信息，这大大提高了推断效率。并且，模型的每一层输出都得到了提升，而不是仅仅是在最后一层输出结果上得到改善，所以运用指数滑动平均，使得目标模型有了更好的<code>中间表示（intermediate representations）</code>。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516170114727.png" alt="image-20230516170114727"></p><p>Teacher 模型参数 θ 的更新公式如下所示，在论文中将模型参数 θ 视作<u><strong>常量</strong></u>，不参与模型训练更新，而是在每一个 step 中按照公式进行迭代更新。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516183523851.png" alt="image-20230516183523851"></p><p>使用三种类型的噪声：</p><ul><li><p>对输入图像输入图像作随机平移和水平翻转</p><p><code>Translation Randomly {∆x, ∆y} ∼ [−2, 2]</code></p><p><code>Horizontal flip Randomly p = 0.5</code></p></li><li><p>Gaussian noise on the input layer</p><p><code>Gaussian noise σ = 0.15</code></p></li><li><p>Dropout</p><p><code>Dropout p = 0.5</code></p></li></ul><p>并且，计算一致性损失（ consistency cost）与上述所提到的模型不同，使用的是<code>均方误差(mean squared error)</code>，</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516185627093.png" alt="image-20230516185627093"></p><p>所使用的初始网络框架为：</p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230516195214426.png" alt="image-20230516195214426" style="zoom: 50%;"><h3 id="Virtual-Adversarial-Training"><a href="#Virtual-Adversarial-Training" class="headerlink" title="Virtual Adversarial Training"></a><a href="https://arxiv.org/abs/1704.03976">Virtual Adversarial Training</a></h3><p>由于有相关公式推导，且篇幅可能会很长（这篇论文理论部分好多…），故单独放在另一篇<a href="https://ytz7.github.io/posts/cc87ae2e.html">博客</a>中。</p><h3 id="Unsupervised-Data-Augmentation"><a href="#Unsupervised-Data-Augmentation" class="headerlink" title="Unsupervised Data Augmentation"></a><a href="https://arxiv.org/abs/1904.12848">Unsupervised Data Augmentation</a></h3><p>该篇论文的关键 idea 是使用 <code>AutoAugment</code> 创建一个未标记的图像的增强版本，使用最小化无标签数据增广数据和无标签数据的 KL 散度，如下图所示，具体思想和半监督学习中其他论文所使用的方法很相似，新鲜点就是论文的增强方式，对待不同任务使用不同的增强方式，且效果都还不错。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230518191734446.png" alt="image-20230518191734446"></p><p>具体细节可查阅<a href="https://ytz7.github.io/posts/77eb0ac8.html">博客</a>。</p><blockquote><p>520 这天还在工位，真实咸鱼一条了 (#｀-_ゝ-) ，但今天见证历史了额，居然不看题解 LeetCode AC 了一道困难题，哈哈哈😊，然后就奖励了自己看一下午的视频（堕落了一下午），shit… 看论文看论文~~</p></blockquote><h2 id="混合方法（Hybrid-Methods）"><a href="#混合方法（Hybrid-Methods）" class="headerlink" title="混合方法（Hybrid Methods）"></a>混合方法（Hybrid Methods）</h2><p>看名字就知道，混合混合，就是把前人所提出的一些方法就行合并，以及添加一些其他组件来提高性能。</p><h3 id="MixMatch"><a href="#MixMatch" class="headerlink" title="MixMatch"></a><a href="https://arxiv.org/abs/1905.02249">MixMatch</a></h3><p>主要工作是在生成数据上做了很大的功夫，但感觉还是很工程…生成数据的算法如下所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520200836920.png" alt="image-20230520200836920"></p><p>对于有标签的数据，对其作一次增强，对于无标签的数据，对其作 K 个不同的增强，生成 K 个对应增强后的数据，并且对 K 个生成后的无标签数据做预测，预测后将其预测分布取平均后的分布作一次<u><strong>锐化</strong></u>，，作为 K 个无标签数据的对应分布，或者可以称之为最终的<u><strong>伪标签</strong></u>。</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520210753737.png" alt="image-20230520210753737"></p><p>得到有标签数据增强后的结果 <code>X^(x, p)</code>，和无标签数据生成后带有伪标签的数据<code>U^(u, q)</code>，过程如下所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520201404911.png" alt="image-20230520201404911"></p><p>然后将增强后的数据 <code>X</code> 和  <code>U</code> 混合后做一次 <u><strong>Shuffle</strong></u>，得到样本集 <code>W</code>，其中前 N 项作为 <code>W_L</code>，剩余的 M 项为 <code>W_U</code>：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520202313703.png" alt="image-20230520202313703"></p><p>锐化公式如下图所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520204542849.png" alt="image-20230520204542849"></p><p>然后将 <u><strong>MixUp</strong></u> 算法运用在上述集合之中，作以下操作：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520202419730.png" alt="image-20230520202419730"></p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520202432527.png" alt="image-20230520202432527"></p><p>其中  <u><strong><a href="https://arxiv.org/abs/1710.09412">MixUp</a></strong></u> 算法为图像增强算法，将两个图像按下面的公式生成新的图像：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520203113608.png" alt="image-20230520203113608"></p><p>为了让 MixUp 方法与损失项更兼容，作者对其做了一点小小的修改：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520212837377.png" alt="image-20230520212837377"></p><p>损失函数如下所示：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520203414452.png" alt="image-20230520203414452"></p><p>输入：<u><strong>相同 batch 大小</strong></u>有标签数据 <code>X</code> 和无标签数据 <code>U</code></p><p>其中 <code>T</code>，<code>K</code>，<code>α</code> 为模型的超参数，<code>α</code> 在 <u><strong>MixUp</strong></u> 中需要使用，<code>T</code> 在<u><strong>锐化</strong></u>中使用到， <code>K</code> 为 K 个不同的<u><strong>数据增强</strong></u>方法：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520204213042.png"></p><p>输出：增强后的结果 <code>X'</code> 和  <code>U'</code></p><p>然后计算有标签数据的损失 <code>L_X</code>，其中 <code>H</code> 为<u><strong>交叉熵</strong></u>，无标签数据的损失 <code>L_U</code>，使用 <u><strong>L2 损失</strong></u>，其中，无标签数据的损失项中 <code>L</code> 是总的标签数量（也就是输入的标签的维度）：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520204253594.png" alt="image-20230520204253594"></p><p>最后，将有标签数据的损失和无标签数据的损失合并，得到最终的损失，其中无监督的损失会对其施加一个权重 <code>λ_U</code>。</p><p>消融实验的结果：</p><p><img src="https://ytz-blog-bucket.oss-cn-guangzhou.aliyuncs.com/typora-markdown/images/image-20230520220721107.png" alt="image-20230520220721107"></p><blockquote><p>OK，按照这个<a href="https://amitness.com/2020/07/semi-supervised-learning/">博主</a>关于半监督学习的综述，终于到达最后一篇经典论文了，不过有件事情一直想吐槽，就是 tensorflow 1. 怎么那么难用啊，本来说想复现一下 MixMatch 的实验，今天捣鼓了一整个下午，还是没有成功，气死我了，后面说是和 Cuda 的版本有冲突，tensorflow 1.15 的版本只能用 Cuda 10. ，服务器上又是 11. 的版本，奈何公共服务器都是大家一起用的，我怕搞得服务器崩了…索性算了，看下一篇去了，以后找论文源码的时候，应该要先找 Pytorch 版本的，不然搞这 tensorflow 又要浪费不少时间。</p><p>算了今天先不写了，会去跑步加和爸妈打打电话吧…</p><p>写于 2023/5/21.</p><p>就写了个开头 😂😅</p></blockquote><h3 id="FixMatch"><a href="#FixMatch" class="headerlink" title="FixMatch"></a><a href="https://arxiv.org/abs/2001.07685">FixMatch</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;半监督学习&quot;&gt;&lt;a href=&quot;#半监督学习&quot; class=&quot;headerlink&quot; title=&quot;半监督学习&quot;&gt;&lt;/a&gt;半监督学习&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;</summary>
      
    
    
    
    <category term="半监督学习" scheme="https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Semi-Surprised-Learning" scheme="https://ytz7.github.io/tags/Semi-Surprised-Learning/"/>
    
    <category term="个人随笔" scheme="https://ytz7.github.io/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
