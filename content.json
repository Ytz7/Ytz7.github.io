{"meta":{"title":"七号zz の Blog","subtitle":"愿为未来做牛马。","description":"废材研究生🤦‍♂️","author":"七号zz","url":"https://Ytz7.github.io","root":"/"},"pages":[{"title":"","date":"2023-09-13T09:03:09.924Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"manifest.json","permalink":"https://ytz7.github.io/manifest.json","excerpt":"","text":"{\"name\":\"七号zz の Blog\",\"short_name\":\"七号zz\",\"theme_color\":\"#eedeab\",\"background_color\":\"#eedeab\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/img/siteicon/16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"},{\"src\":\"/img/siteicon/32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"},{\"src\":\"/img/siteicon/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/img/siteicon/64.png\",\"sizes\":\"64x64\",\"type\":\"image/png\"},{\"src\":\"/img/siteicon/128.png\",\"sizes\":\"128x128\",\"type\":\"image/png\"},{\"src\":\"/img/siteicon/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/img/siteicon/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"about","date":"2023-04-24T14:13:26.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"about/index.html","permalink":"https://ytz7.github.io/about/index.html","excerpt":"","text":"关于我一个废材研究生ISFJ/守护者让我在抑郁的边缘徘徊"},{"title":"分类","date":"2023-04-24T14:13:14.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"categories/index.html","permalink":"https://ytz7.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-09-13T09:03:09.924Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"js/ali_font.js","permalink":"https://ytz7.github.io/js/ali_font.js","excerpt":"","text":"!(function (c) { var l, h, a, t, i, v = '', o = (o = document.getElementsByTagName(\"script\"))[o.length - 1].getAttribute(\"data-injectcss\"), p = function (c, l) { l.parentNode.insertBefore(c, l); }; if (o &amp;&amp; !c.__iconfont__svg__cssinject__) { c.__iconfont__svg__cssinject__ = !0; try { document.write( \".svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}\" ); } catch (c) { console &amp;&amp; console.log(c); } } function d() { i || ((i = !0), a()); } function m() { try { t.documentElement.doScroll(\"left\"); } catch (c) { return void setTimeout(m, 50); } d(); } (l = function () { var c, l = document.createElement(\"div\"); (l.innerHTML = v), (v = null), (l = l.getElementsByTagName(\"svg\")[0]) &amp;&amp; (l.setAttribute(\"aria-hidden\", \"true\"), (l.style.position = \"absolute\"), (l.style.width = 0), (l.style.height = 0), (l.style.overflow = \"hidden\"), (l = l), (c = document.body).firstChild ? p(l, c.firstChild) : c.appendChild(l)); }), document.addEventListener ? ~[\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) ? setTimeout(l, 0) : ((h = function () { document.removeEventListener(\"DOMContentLoaded\", h, !1), l(); }), document.addEventListener(\"DOMContentLoaded\", h, !1)) : document.attachEvent &amp;&amp; ((a = l), (t = c.document), (i = !1), m(), (t.onreadystatechange = function () { \"complete\" == t.readyState &amp;&amp; ((t.onreadystatechange = null), d()); })); })(window);"},{"title":"友情链接","date":"2023-04-24T14:25:31.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"link/index.html","permalink":"https://ytz7.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-04-24T14:12:42.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"tags/index.html","permalink":"https://ytz7.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SimMatch","slug":"SimMatch","date":"2023-09-02T12:10:38.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/697723e2.html","link":"","permalink":"https://ytz7.github.io/posts/697723e2.html","excerpt":"","text":"SimMatch: Semi-supervised Learning with Similarity Matching - CVPR 2022","categories":[{"name":"半监督学习","slug":"半监督学习","permalink":"https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Semi-Surprised-Learning","slug":"Semi-Surprised-Learning","permalink":"https://ytz7.github.io/tags/Semi-Surprised-Learning/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://ytz7.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"MMDetection","slug":"MMDetection","date":"2023-06-06T09:02:27.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/73d20edf.html","link":"","permalink":"https://ytz7.github.io/posts/73d20edf.html","excerpt":"","text":"MMDetection 踩坑之路 每天都在配环境，每时每刻都在烦… 参考：依赖 — MMDetection 2.17.0 文档 安装配置安装 Pytorch123&gt; 更新 pip&gt; python -m pip install --upgrade pip&gt; pip install torch==1.9.1+cu111 torchvision==0.10.1+cu111 torchaudio==0.9.1 -f https://download.pytorch.org/whl/torch_stable.html 安装 mmcv-full推荐安装 mmcv-full，包含所有功能，而简版为 mmcv，并且，下载时必须从 openmmlab 官网下载，下载源格式为： 1https://download.openmmlab.com/mmcv/dist/cu${CUDA_VERSION }/torch{TORCH_VERSION }/index.html 当 cuda 版本为 10.1 时，则为 cu101；11.1 时，为 cu111 torch 的版本不管为 1.9.5 还是 1.9.1，小版本都归零，即 1.9.0 在 CUDA 11.1，torch 版本为 1.9.1 的版本下，下载地址为： 1https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html 完整的命令为： 1&gt; pip install mmcv-full==1.3.17 -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.9.0/index.html 安装 mmdetection需要注意依赖，参考首行的官方文档： 1&gt; pip install mmdet==2.25 学习 MMDetection对数据做增强1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 强增强 - SoftTeacherstrong_pipeline = [ dict( type=\"Sequential\", transforms=[ dict( type=\"RandResize\", img_scale=[(1333, 400), (1333, 1200)], multiscale_mode=\"range\", keep_ratio=True, ), dict(type=\"RandFlip\", flip_ratio=0.5), dict( type=\"ShuffledSequential\", transforms=[ dict( type=\"OneOf\", transforms=[ dict(type=k) for k in [ \"Identity\", \"AutoContrast\", \"RandEqualize\", \"RandSolarize\", \"RandColor\", \"RandContrast\", \"RandBrightness\", \"RandSharpness\", \"RandPosterize\", ] ], ), dict( type=\"OneOf\", transforms=[ dict(type=\"RandTranslate\", x=(-0.1, 0.1)), dict(type=\"RandTranslate\", y=(-0.1, 0.1)), dict(type=\"RandRotate\", angle=(-30, 30)), [ dict(type=\"RandShear\", x=(-30, 30)), dict(type=\"RandShear\", y=(-30, 30)), ], ], ), ], ), dict( type=\"RandErase\", n_iterations=(1, 5), size=[0, 0.2], squared=True, ), ], record=True, ), dict(type=\"Pad\", size_divisor=32), dict(type=\"Normalize\", **img_norm_cfg), dict(type=\"ExtraAttrs\", tag=\"unsup_student\"), dict(type=\"DefaultFormatBundle\"), dict( type=\"Collect\", keys=[\"img\", \"gt_bboxes\", \"gt_labels\"], meta_keys=( \"filename\", \"ori_shape\", \"img_shape\", \"img_norm_cfg\", \"pad_shape\", \"scale_factor\", \"tag\", \"transform_matrix\", ), ),] 这段代码中定义了一个强增强的 pipeline，包括以下几个部分： RandResize：随机对图像进行缩放，可以生成不同尺度的图像来增加训练数据的多样性。 RandFlip：随机对图像进行水平或垂直翻转，可以帮助模型学习不同角度的物体。 ShuffledSequential：将后续的增强操作随机打乱，以增加数据的多样性。 OneOf：从一组增强操作中随机选择一个进行操作，包括： Identity：原图不变 AutoContrast：自动调整图像对比度 RandEqualize：随机增强直方图均衡化 RandSolarize：随机增强 Solarization 效果 RandColor：随机改变图像颜色平衡 RandContrast：随机增强图像对比度 RandBrightness：随机改变图像亮度 RandSharpness：随机增强图像锐利度 RandPosterize：随机降低图像位深度 OneOf：从一组增强操作中随机选择一个进行操作，包括： RandTranslate：随机对图像进行平移 RandRotate：随机对图像进行旋转 RandShear：随机对图像进行剪切 RandErase：随机擦除图像中的像素，增加模型对图像噪声和遮挡的鲁棒性。 Pad：将图像填充至指定大小的倍数，用于处理不同大小的图像以及特定的 GPU 加速要求。 Normalize：对图像进行标准化处理，将像素值映射到均值为 0，方差为 1 的分布中。 ExtraAttrs：添加一个额外的属性，用于标记数据被传入模型的来源（这里标记为 “unsup_student”）。 DefaultFormatBundle：将图像数据打包为默认格式。 Collect：将图像及其标注信息收集到一个字典中，以供后续处理。 12345678910111213141516171819202122232425262728293031323334# 弱增强 - SoftTeacherweak_pipeline = [ dict( type=\"Sequential\", transforms=[ dict( type=\"RandResize\", img_scale=[(1333, 400), (1333, 1200)], multiscale_mode=\"range\", keep_ratio=True, ), dict(type=\"RandFlip\", flip_ratio=0.5), ], record=True, ), dict(type=\"Pad\", size_divisor=32), dict(type=\"Normalize\", **img_norm_cfg), dict(type=\"ExtraAttrs\", tag=\"unsup_teacher\"), dict(type=\"DefaultFormatBundle\"), dict( type=\"Collect\", keys=[\"img\", \"gt_bboxes\", \"gt_labels\"], meta_keys=( \"filename\", \"ori_shape\", \"img_shape\", \"img_norm_cfg\", \"pad_shape\", \"scale_factor\", \"tag\", \"transform_matrix\", ), ),] 这是一段弱增强的代码，主要包括以下几个部分： RandResize：随机对图像进行缩放，可以生成不同尺度的图像来增加训练数据的多样性。 RandFlip：随机对图像进行水平或垂直翻转，可以帮助模型学习不同角度的物体。 Pad：将图像填充至指定大小的倍数，用于处理不同大小的图像以及特定的 GPU 加速要求。 Normalize：对图像进行标准化处理，将像素值映射到均值为 0，方差为 1 的分布中。 ExtraAttrs：添加一个额外的属性，用于标记数据被传入模型的来源（这里标记为 “unsup_teacher”）。 DefaultFormatBundle：将图像数据打包为默认格式。 Collect：将图像及其标注信息收集到一个字典中，以供后续处理。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://ytz7.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[]},{"title":"Faster-RCNN","slug":"faster-rcnn","date":"2023-05-28T09:08:02.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/c018b3e5.html","link":"","permalink":"https://ytz7.github.io/posts/c018b3e5.html","excerpt":"","text":"Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks 记一次过度饮酒后的第二天…真的痛苦 看了好几篇在目标检测算法应用半监督学习的文章，感觉好多都是基于 Faster RCNN 作为其主干网络来实现，但是对于目标检测算法，目前只对于 YOLOv3（One-Stage）有所了解，所以说，还是需要对其他目标检测的算法有所了解才好。 论文地址： Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks 参考文章： Pytorch搭建Faster R-CNN目标检测平台 RCNN、Fast-RCNN、Faster-RCNN网络详解 Faster RCNN的一些笔记 RPN 解析 参考视频： 霹雳吧啦Wz Bubbliiiing RCNN 算法流程 一张图片生成1k~2k个候选区域(使用Selective Search方法)； 对每个候选区域，使用深度网络(即图片分类网络)提取特征； 特征送入每一类的SVM分类器，判别是否属于该类； 使用回归器精细修正候选框位置。 Selective Search 方法是一种通过图像分割方法来生成一些原始区域的方法，使用一些合并策略将这些区域合并，得到一个层次化的区域结构，这些结构就包含着可能需要的物体。简而言之，Selective Search 方法用于生成候选框。 对每个候选区域，使用深度网络提取特征后，将 2000 个候选区域分别缩放到 227 * 227 的大小（AlexNet CNN 的输入大小），通过 CNN 提取特征。获取 4096 维的特征，得到 2000 * 4096 维特征矩阵： 然后将特征送入每一类的SVM分类器来判定类别，将 2000 * 4096 维特征与 20 个SVM（Pascal VOC 有 20 个类别）组成的权值矩阵 4096 * 20 相乘，获得 2000 * 20 维矩阵表示每一个建议框是某个目标类别的得分，即在矩阵中 [i, j] 表示第 i 个建议框中是第 j 类的概率大小。 分别对上述 2000 * 20 维矩阵中每一列即每一类进行非极大值抑制提出重叠建议框，得到该列（即该类中）得分最高的一些建议框。 使用回归器精细修正候选框位置，分别用 20 个回归器对上述 20 个类别中剩余的建议框进行回归操作，最终得到每个类别的修正后得分最高的 bounding box。 如下图所示，黄色窗口 P 表示建议框 Region Proposal，绿色窗口 G 表示实际框Ground Truth，红色窗口 G^ 表示 Region Proposal 进行回归后的预测窗口。 Fast-RCNN 算法流程具体流程如下图所示： SPPNet / ROI pooling layer在 RCNN 的基础上对于提取特征的步骤做了改进： 将整个图像输入到 CNN 中得到特征图，再将 Selective Search 方法得到的候选框投影到特征图上，得到特征矩阵 即 SPPNet，与 RCNN 的对比如下图所示： 根据每个候选区域原图与特征图的映射关系，就能在特征图中直接获取特征矩阵，这些候选区域的特征不需要再重复计算。 对于候选区域的 size 各异的限制，RCNN 通过对候选区域做变换得到，即放缩，在 SPPNet 中由 spatial pyramid pooling 解决，将原始网络中最后一个池化层改进成了空间金字塔池化层，它可以将任意尺寸的特征图转化为固定大小的特征向量从而不同尺寸的候选区域的不同大小特征图样切片也可以转化成相同大小的特征向量以进行后续判决： softmax 分类器输出 N+1 个类别的概率（目标总类别 + 背景），共 N+1 个节点： bbox regressor 边界框回归器输出对应 N+1 个类别的候选边界框回归参数（dx, dy, dw, dh），共 （N+1） * 4 个节点： 利用回归得到的参数得到边界框： Faster-RCNN 算法流程 将图像输入网络得到相应的特征图； 使用 RPN 结构生成候选框，将 RPN 生成的候选框投影到特征图上获得相应的特征矩阵； 将每个特征矩阵通过 ROI(Region of Interest) pooling 层缩放到 7x7 大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果。 Faster-RCNN 可以理解为 RPN + Fast-RCNN，右半部分即为 Fast-RCNN。 RPN RPN，全称为 Region Proposal Network，Region Proposal 为区域提取，RPN 就是用来提取候选框的网络 利用深度卷积神经网络来计算初始的候选区域，一个特征图通过滑动窗口，得到256 维特征，其中一个 grid 生成 k 个 anchor boxes，通过两次全连接得到 2k 个分数和 4k 个坐标，如下图所示，其中 cls 代表类别预测，分别预测背景概率和前景概率，前景概率即为区域中是否带有对象的概率，可以视作二分类问题，而 reg 则为 k 个 boxes 的四个参数的预测，分别为：中心点坐标和宽高。 在论文中提出了三种尺度（）和三种比例作为 anchor，每个位置在原图上都对于有 9 个 anchor，对于 RPN 生成的候选框之间存在大量重叠，基于候选框的 cls 得分，采用非极大抑制筛选候选框。最后对应于原图的候选框生成结果可以由下图简略概括： RPN 的输入特征图指的是哪个特征图？ RPN 的输入特征图就是 Faster-RCNN 中的公共 feature map，主要用以 RPN 和 RoI Pooling 共享。 损失函数 其中，p 表示的是 anchor 为一个 object 的概率，p* 为 1 时则表示该 anchor 为正样本（positive），反之，则为负样本（negative）。 判断 anchor 是否为正样本： 与 Grounding Truth 的重叠区域 IoU 超过 0.7 为了防止条件 1 筛选过后不存在正样本，故使 IoU 最大的 anchor 也为正样本 Training RPNs RPN 通过反向传播和随机梯度下降法进行端到端的训练 随机从一张图片中采样 256 个 anchors，计算一个 mini-batch 的损失函数 采样的 positive anchors 和 negative anchors 的比例是 1 : 1，若正样本少于 128，则从负样本中采样填充 所有层通过 ImageNet 预训练模型进行初始化 Sharing Features for RPN and Fast R-CNN 这一个地方看得不是很懂… RPN和Fast R-CNN共享特征，论文中采用的是：Alternating training： 首先训练 RPN 层，然后用所得到的 proposals 来训练 Fast-RCNN（此时设置 RPN层不更新），然后得到的 Fast-RCNN，再来初始化并训练 RPN 层，然后再迭代往复。 目的：为了使两个不同任务能够共享卷积层。 具体训练细节： 训练 RPN，使用 ImageNet 预训练权重，并且在 region proposal 任务上进行训练微调 使用生成的 region proposal 在 Fast R-CNN 上进行训练，同意使用 ImageNet 预训练权重 使用所训练的目标检测网络（Fast R-CNN）来初始化 RPN 训练权重，但固定共享的卷积层，仅微调 RPN 独有的层 让共享的卷积层继续固定，训练微调 Fast R-CNN 独有的层 现在是 2023/05/29 22：38，看代码看得有点昏，走咯走咯，下班… git push 一哈🤦‍♂️","categories":[{"name":"目标检测","slug":"目标检测","permalink":"https://ytz7.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Object-Detection","slug":"Object-Detection","permalink":"https://ytz7.github.io/tags/Object-Detection/"}]},{"title":"2023 年下半年计划","slug":"learning-plan-2023secondhalf","date":"2023-05-24T05:48:14.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/68092092.html","link":"","permalink":"https://ytz7.github.io/posts/68092092.html","excerpt":"","text":"打算做半监督目标检测方向，理清以下下半年的计划，该学习什么，该怎样学习，不然像个无头苍蝇一样四处乱撞… 定一个计划把，看看自己是否能够坚持下来，学完一篇就在这边打卡，但我不知道这样子做会不会太慢？… 不过还是要处理一下前几天看的 FixMatch 的代码细节还没看完，先把这个东西收尾收掉把。 2023-05-24 记录：FixMatch 代码收尾结束，果然看代码对于 Coding 也会有些帮助，尤其是在上次看完 YOLOv3 的代码之后，之前感觉还挺害怕看代码的… Ps： chatGPT 真好用🤗 Coding 能力感觉自己的 Python 基础相当的差啊，对 Pytorch 也不这么熟悉，或者说只会看代码和运行别人的代码🤦‍♂️，那么该如何解决这一个棘手的问题呢？ 霹雳吧啦Wz的个人空间_哔哩哔哩_bilibili 学习这个博主关于图像分类方面的代码，尽量要试着阅读和手写代码 目标检测方面对于目标检测的基础只是还是需要了解的，具体可以看下面这个博主的视频学习，也是能阅读代码就阅读代码，（手写代码） Bubbliiiing的个人空间_哔哩哔哩_bilibili 半监督目标检测方向一文梳理目标检测的半监督学习 (qq.com) 首先肯定是了解先前的相关经典论文，不过不需要精读，需要精度的是这两年以内的论文，然后再去复现论文。","categories":[{"name":"学习计划","slug":"学习计划","permalink":"https://ytz7.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"}],"tags":[]},{"title":"Pytorch 学习","slug":"pytorch-learning","date":"2023-05-22T14:05:21.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/9f542fbf.html","link":"","permalink":"https://ytz7.github.io/posts/9f542fbf.html","excerpt":"","text":"好久没有写 python了，对于 pytorch 的语法什么的都忘光光了，写着一篇博客来记录我学习的过程，以及途中遇到的 bug 和解决方法，希望我的 coding 能力能够有所提升… 环境安装配置问题安装 CUDA（Linux 环境）查看 CUDA 状态123&gt; # 查看 cuda&gt; naidia-smi&gt; nvcc -V conda create 无法使用记录一下 conda create 命令无法使用的问题： 原因在于配置文件好像解析不了，于是将配置文件 .condarc 中的内容替换为： 123456789101112131415161718channels: - defaultsshow_channel_urls: truechannel_alias: https://mirrors.tuna.tsinghua.edu.cn/anacondadefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloudssl_verify: true 更改完成后，在命令行输入以下命令完成配置的更新： 1conda config --set show_channel_urls yes Linux 中 bash 执行 .sh 文件当出现 $'\\r': command not found，是因为 Windows 和 Linux 的 sh 一些文件格式不同： 以换行为例，Windows 中是 \\r\\n，而 Linux 中则是 \\n，所以才会报 \\r’: command not found 如何解决？ 123456&gt; # 利用 vi 打开文件 xx.sh&gt; # 打开分别输入指令&gt; # 换行符转换&gt; :set ff=unix&gt; # 保存退出&gt; :wq 安装 Pytorch就拿最近看的论文 FixMatch 的环境失手，代码需要： python 3.6+ torch 1.4 torchvision 0.5 tensorboard numpy tqdm apex (optional) 创建虚拟环境 fixmatch，这里我选择 python 版本为 3.7： 12conda create -n fixmatch python=3.7conda activate fixmatch 访问 Pytorch 的官网选择对应版本的 torch 和 torchvision 即可： Previous PyTorch Versions | PyTorch 下载 torch==1.4.0 和torchvision==0.5.0，这里需要加上后缀 -f https://download.pytorch.org/whl/torch_stable.html，因为配置下载源为清华源，好像在清华源中找不到这个版本，所以以后都直接从 Pytorch 官网下载即可： 123pip install torch==1.4.0 torchvision==0.5.0 -f https://download.pytorch.org/whl/torch_stable.htmlpip install tensorboardpip install tqdm 测试是否可以使用，加入 python 环境，显示以下信息就算安装成功： 12345&gt;&gt;&gt; import torch&gt;&gt;&gt; torch.cuda.is_available()True&gt;&gt;&gt; torch.__version__'1.4.0+cu92' 安装 Pytorch 和 mmdetection学习过程torch 函数使用torch.manual_seed()在神经网络中，参数默认是进行随机初始化的。如果不设置的话每次训练时的初始化都是随机的，导致结果不确定。 如果设置初始化，则每次初始化都是固定的。 实际上，计算机并不能产生真正的随机数，而是已经编写好的一些无规则排列的数字存储在电脑里，把这些数字划分为若干相等的 N 份，并为每份加上一个编号，编号固定的时候，获得的随机数也是固定的。 torch.manual_seed(1) 用于设置随机初始化的种子，即上述的编号，编号固定，每次获取的随机数固定。 1234567if args.seed is not None: random.seed(args.seed) torch.manual_seed(args.seed) #为CPU设置种子用于生成随机数，以使结果是确定的 torch.cuda.manual_seed(args.seed) #为当前GPU设置随机种子； cudnn.deterministic = True # 如果使用多个GPU，应该使用torch.cuda.manual_seed_all()为所有的GPU设置种子。 torch.distributed.barrier()这是示例代码： 12345678if args.local_rank not in [-1, 0]: torch.distributed.barrier() labeled_dataset, unlabeled_dataset, test_dataset = DATASET_GETTERS[args.dataset]( args, './data')if args.local_rank == 0: torch.distributed.barrier() 关于参数 local_rank 的理解： 在使用多进程处理任务时，在 Python 中通常设置等级 0 是第一个进程或基本进程，然后对其他进程进行不同的排序，例如 1、2、3 加上基本进程 0，总共 4 个进程。 使用单进程时，往往会设置进程号为 -1，总而言之，当 local_rank 为 0/-1 时，认为它是主进程。 对于多进程任务，往往只需要一个进程预处理数据或者读取数据，而为了与其他进程共享数据，需要在主进程处理数据的时候让其他进程全部停下来等待。 上述的代码示例，实际的功能如下： 12345678910111213# 询问当前进程是否为主进程if args.local_rank not in [-1, 0]: # 不是主进程，阻塞 # 让该进程加入 barrier() torch.distributed.barrier() # 主进程读取数据labeled_dataset, unlabeled_dataset, test_dataset = DATASET_GETTERS[args.dataset]( args, './data')# 主进程读取数据完毕，主进程加入 barrier()if args.local_rank == 0: torch.distributed.barrier() 当所有的进程都进入了 barrier() 后，Pytorch 就会打开所有的 barrier()，所有的进程都可以继续进行相关操作。 当需要进行阻塞操作时，模板即为： 1234567891011if args.local_rank not in [-1, 0]: torch.distributed.barrier()'''主进程进行操作'''.........if args.local_rank == 0: torch.distributed.barrier() 总结： 当进程遇到障碍时，它将阻塞 屏障的位置并不重要（例如，并非所有进程都必须输入相同的 if 语句） 一个进程被一个屏障阻塞，直到所有进程都遇到一个屏障，在这个屏障上为所有进程解除这些屏障 model.named_parameters()model.named_parameters() 将会打印每一次迭代元素的名字和 param： 1234model = DarkNet([1, 2, 8, 8, 4])for name, param in model.named_parameters(): print(name,param.requires_grad) param.requires_grad = False 12345678910111213141516171819conv1.weight Truebn1.weight Truebn1.bias Truelayer1.ds_conv.weight Truelayer1.ds_bn.weight Truelayer1.ds_bn.bias Truelayer1.residual_0.conv1.weight Truelayer1.residual_0.bn1.weight Truelayer1.residual_0.bn1.bias Truelayer1.residual_0.conv2.weight Truelayer1.residual_0.bn2.weight Truelayer1.residual_0.bn2.bias Truelayer2.ds_conv.weight Truelayer2.ds_bn.weight Truelayer2.ds_bn.bias Truelayer2.residual_0.conv1.weight Truelayer2.residual_0.bn1.weight Truelayer2.residual_0.bn1.bias True.... torch.nn.parallel.DistributedDataParallel1234567891011\"\"\"在分布环境中实现数据并行训练 torch.nn.parallel.DistributedDataParallel - model 需要进行数据并行训练的模型对象 - device_ids=[args.local_rank] 指定在哪些设备上进行数据并行训练 - output_device=args.local_rank 指定输出的设备 - find_unused_parameters=True 指定是否查找未使用的参数。 当模型具有不同分支或子模块具有不同输入形状时，可能会出现未使用的参数。\"\"\"model = torch.nn.parallel.DistributedDataParallel( model, device_ids=[args.local_rank], output_device=args.local_rank, find_unused_parameters=True) tensor.chunk().chunk()是PyTorch张量的一个方法，用于将张量沿着指定维度进行均匀切分成多个子张量。 具体来说，.chunk()的功能如下： 语法：chunk(chunks, dim=0) 参数： chunks：表示要切分的块数。 dim：表示要在哪个维度上进行切分，默认为0（第一个维度）。 返回值：返回一个元组，包含切分后的子张量。 .chunk()方法会将原始张量沿着指定维度进行均匀切分，每个子张量的大小相等（除非原始张量的大小无法被整除）。返回的结果是一个元组，其中包含切分后的子张量。 1logits_u_w, logits_u_s = logits[batch_size:].chunk(2) 在给定的代码中，logits[batch_size:].chunk(2)将张量logits从索引batch_size开始切分成两个子张量。这样可以将模型输出的结果划分为两个部分，分别赋值给logits_u_w和logits_u_s。 tensor.detach().detach()是PyTorch张量的一个方法，用于创建一个新的张量，其中包含了原始张量的数据，但没有建立与计算图的连接。 具体来说，.detach()的功能如下： .detach()会返回一个新的张量，其中包含了原始张量的数据，但没有梯度信息和计算图的连接。这意味着通过.detach()得到的张量不会参与反向传播过程，不会对梯度进行求导。 常见的使用场景包括： 当你只对部分张量进行梯度计算时，可以使用.detach()将其与其他需要梯度的张量分离。 当你需要在不影响原始张量梯度的情况下，对张量进行操作或传递给其他函数。 总而言之，.detach()方法可以用于生成不需要梯度的张量，并且在某些情况下，可以提高效率并避免梯度传播的影响。 tensor.flatten(start_dim=1)x.flatten(start_dim=1) 表示将 x 沿着从 start_dim 开始的所有维度拉平成一个一维张量，返回的结果是一个新的张量。 具体来说，假设 x 的形状为 (B, C, H, W)，其中 B 表示 batch size，C 表示通道数，H 表示高度，W 表示宽度，那么 x.flatten(start_dim=1) 的结果是一个形状为 (B, C*H*W) 的张量，即将除了 B 以外的所有维度都拉平成一个维度。 如果 start_dim 是默认值 0，则相当于将整个张量拉平成一个一维张量，即形状为 (B*C*H*W,)。 如果 start_dim 是 2，假设 x 的形状为 (B, C, H, W)，则表示从第二个维度 C 开始将 x 沿着后面的维度拉平成一个一维张量，返回的结果是一个形状为 (B, C, H*W) 的张量。 具体来说，对于每个样本数据，张量中第二个维度 C 之后的所有维度都被拉平成为一个维度，而前两个维度 B 和 C 保持不变，因此结果的形状是 (B, C, H*W)。 举个例子，如果 x 的形状是 (2, 3, 4, 5)，那么 x.flatten(start_dim=2) 的结果将是一个形状为 (2, 3, 20) 的张量。其中，第 1 个样本的维度为 (3, 4, 5)，被拉平成了 (3, 20)；第 2 个样本的维度也是 (3, 4, 5)，被拉平成了 (3, 20)。因此结果的形状是 (2, 3, 20)。 zip()Python 中使用 zip() 函数同时循环遍历多个列表，例如： for s, a in zip(self.sizes, self.aspect_ratios)， 其中： self.sizes 是一个包含 3 个元素的列表，对应 3 个预定义的尺度（以像素值的平方根为度量） sizes=(128, 256, 512) self.aspect_ratios 是一个包含 3 个元素的列表，对应 3 种预定义的宽高比 aspect_ratios=(0.5, 1.0, 2.0) zip(self.sizes, self.aspect_ratios) 返回的是一个可迭代对象，每次迭代会输出 self.sizes 和 self.aspect_ratios 中对应位置的元素，即 (s₁, a₁), (s₂, a₂), ...。 model.parameters() 和 model.buffers()在 PyTorch 中，model.parameters()和model.buffers()都是用于获取模型中的参数和缓冲区的函数，但是它们获取的内容不同。 model.parameters()函数返回模型中需要训练的参数。这些参数通常对应着网络的权重和偏置值，以及其他可更新的变量。调用model.parameters()函数通常用于定义优化器，从而在训练网络时更新这些参数。 model.buffers()函数返回模型中所有不需要训练的缓冲区，比如BN层和移动平均层的移动平均值和方差。缓冲区也需要在模型定义时被注册，但是它们不需要参与训练，因此也不会影响梯度的计算和更新过程。调用model.buffers()函数通常用于模型的保存和恢复，以及其他需要获取缓冲区的操作。 nn.BatchNorm2d在 PyTorch 中，Batch Normalization 层（BN 层）是通过在模型中添加一个特殊的 nn.BatchNorm2d 类来实现的。其缓冲区包括： running_mean：用于计算训练过程中的均值，每次更新一批数据后就会更新。 running_var：用于计算训练过程中的方差，每次更新一批数据后就会更新。 weight：会被模型学习到的尺度因子。 bias：会被模型学习到的偏移参数。 当模型向前传播时，BN 层会将输入数据按维度计算出均值和方差，然后使用这些均值和方差对数据进行归一化操作。归一化后的数据会受到 weight 和 bias 的影响，然后被传递给下一层作为输入。 注意到在添加了 BN 层后，我们在传递数据到下一层之前需要使用 ReLU 激活函数。 nn.BatchNorm2d 的实现细节如下： 假设输入的形状是 (batch_size, channels, height, width)，则 BatchNorm2d 层会按照 channels 维度计算每一个元素对应的均值和方差，接着使用这些均值和方差对输入数据进行归一化。归一化后的数据会受到权重参数 weight（形状为 (channels,)）和偏置参数 bias（形状也是 (channels,)）的影响，最终输出形状也是 (batch_size, channels, height, width)。 torch.unique_consecutive(*args, **kwargs)参数： input(Tensor) -输入张量 return_inverse(bool) -是否还返回原始输入中的元素在返回的唯一列表中结束的位置的索引。 return_counts(bool) -是否还返回每个唯一元素的计数。 dim(int) -要应用唯一的维度。如果 None ，则返回展平输入的唯一性。默认值：None 返回： 一个张量或一个张量元组包含 输出(张量)：唯一标量元素的输出列表。 inverse_indices(张量)：(可选)如果return_inverse为 True，将有一个额外的返回张量(与输入的形状相同)表示原始输入中的元素映射到输出中的位置的索引；否则，此函数将仅返回一个张量。 计数(张量)：(可选)如果return_counts为 True，将有一个额外的返回张量(与 output 或 output.size(dim) 的形状相同，如果指定了 dim )表示每个唯一值或张量的出现次数。 例子： 12345678910111213141516&gt;&gt;&gt; x = torch.tensor([1, 1, 2, 2, 3, 1, 1, 2])&gt;&gt;&gt; output = torch.unique_consecutive(x)&gt;&gt;&gt; outputtensor([1, 2, 3, 1, 2])&gt;&gt;&gt; output, inverse_indices = torch.unique_consecutive(x, return_inverse=True)&gt;&gt;&gt; outputtensor([1, 2, 3, 1, 2])&gt;&gt;&gt; inverse_indicestensor([0, 0, 1, 1, 2, 3, 3, 4])&gt;&gt;&gt; output, counts = torch.unique_consecutive(x, return_counts=True)&gt;&gt;&gt; outputtensor([1, 2, 3, 1, 2])&gt;&gt;&gt; countstensor([2, 2, 1, 2, 1]) torch.cumsumtorch.cumsum 是 PyTorch 中的一个函数，用于计算张量元素的累加和。 具体来说，对于一个一维张量（长度为 n），torch.cumsum(input, dim=0) 返回一个同样长度的张量，其中每个位置的元素为原张量中该位置及之前位置的元素的累加和。例如： 123456import torcha = torch.tensor([1, 2, 3, 4, 5])b = torch.cumsum(a, dim=0)print(b)# output: tensor([ 1, 3, 6, 10, 15]) 对于一个多维张量，torch.cumsum(input, dim) 会沿着指定维度 dim 进行累加。例如，对于一个二维张量（shape 为 (m, n)），torch.cumsum(input, dim=0) 会返回一个与原张量尺寸相同的张量，其中每列都沿着行方向进行元素累加。 具体实现可以参考 PyTorch 文档中的说明：torch.cumsum。 统计模型参数首先对于计算模型的FLOPs而言，fvcore是一个易用的工具。fvcore是Facebook开源的一个轻量级的核心库，它提供了各种计算机视觉框架中常见且基本的功能。其中就包括了统计模型的参数以及FLOPs等。fvcore项目的开源地址是： facebookresearch/fvcore: Collection of common code that’s shared among different research projects in FAIR computer vision team. (github.com) 如果需要使用fvcore，首先需要安装： 1pip install fvcore 对于FlOPs，我们先解释一下其概念： FLOPS：注意全大写，是floating point operations per second的缩写，意指每秒浮点运算次数，理解为计算速度。是一个衡量硬件性能的指标。 FLOPs：注意s小写，是floating point operations的缩写（s表复数），意指浮点运算数，理解为计算量。可以用来衡量算法/模型的复杂度。 注意，模型的参数量少不代表FLOPs低，理论的FLOPs低也不代表实际的推理速度快。 1234567891011121314151617181920212223242526272829303132333435import torchfrom torchvision.models import resnet50from fvcore.nn import FlopCountAnalysis, parameter_count_tabledef print_models_param_nums(model): \"\"\"counts and prints the number of models parameters Args: model (_type_): model \"\"\" total = sum([param.numel() for param in model.parameters()]) print(' + Number of params: %.2fM' % (total / 1e6))def count_models_param_nums(model): \"\"\"counts and the number of models parameters\"\"\" return sum(p.numel() for p in model.parameters()) / 1e6if __name__ == '__main__': # 创建 resnet50 网络 model = resnet50(num_classes=1000) # 创建输入网络的 tensor tensor = (torch.rand(1, 3, 224, 224),) # 分析 FLOPS flops = FlopCountAnalysis(model, tensor) print(\"Flops: {}\".format(flops.total())) # 计算模型的参数量 print(parameter_count_table(model)) # 自定义函数统计模型的参数量 count_models_param_nums(model) # 输出模型的总参数 print(\"Total params: {:.2f}M\".format(count_models_param_nums(model))) 封装数据集训练技巧多卡训练使用多卡训练的方式有很多，当然前提是我们的设备中存在两个及以上的GPU：使用命令 nvidia-smi 查看当前Ubuntu平台的GPU数量，在我们设备中确实存在多卡的条件下，最简单的方法是直接使用 torch.nn.DataParallel 将模型wrap一下即可： 1net = torch.nn.DataParallel(model) 这时，默认所有存在的显卡都会被使用。 如果机子中有很多显卡，但只想使用0、1、2号显卡，那么可以： 123os.environ[\"CUDA_VISIBLE_DEVICES\"] = ','.join(map(str, [0,1,2]))net = torch.nn.DataParallel(model)# CUDA_VISIBLE_DEVICES 表示当前可以被python环境程序检测到的显卡 权重衰退（weight_decay） 正则化：凡事可以减少泛化误差而不是减少训练误差的方法，都可以称作正则化方法。 权重衰退是一种最常见的处理过拟合的方法，通常也被称为 L2 正则化 权值衰减 是一直以来经常被使用的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。很多过拟合原本就是因为权重参数取值过大才发生的。为损失函数加上权重的平方范数（L2 范数），就可以抑制权重变大，λ 是控制正则化强度的超参数，λ 设置得越大，对大的权重施加的惩罚就越重。 以下是一段示例代码： 123456789no_decay = ['bias', 'bn']grouped_parameters = [ {'params': [p for n, p in model.named_parameters() if not any( nd in n for nd in no_decay)], 'weight_decay': args.wdecay}, {'params': [p for n, p in model.named_parameters() if any( nd in n for nd in no_decay)], 'weight_decay': 0.0}]optimizer = optim.SGD(grouped_parameters, lr=args.lr, momentum=0.9, nesterov=args.nesterov) no_decay 表示不应用权重衰减（weight decay）的参数，其中，偏置（bias）和批归一化（batch normalization）参数不会受到权重衰减的影响 grouped_parameters 中： params 一个包含参数（parameter）的列表，根据特定的条件选择模型中的参数，第一个字典中选择的是受权重衰减影响的参数，第二个字典中选择的是不受权重衰减影响的参数 weight_decay 权重衰减的值 optimizer 是一个使用随机梯度下降（Stochastic Gradient Descent, SGD）算法进行优化的对象，接受以下参数： 12345678910111213141516171819202122232425262728class SGD( params: _params_t, lr: float, momentum: float = ..., dampening: float = ..., weight_decay: float = ..., nesterov: bool = ...) \"\"\"Implements stochastic gradient descent (optionally with momentum). Nesterov momentum is based on the formula from On the importance of initialization and momentum in deep learning__. Args: params (iterable): iterable of parameters to optimize or dicts defining parameter groups lr (float): learning rate momentum (float, optional): momentum factor (default: 0) weight_decay (float, optional): weight decay (L2 penalty) (default: 0) dampening (float, optional): dampening for momentum (default: 0) nesterov (bool, optional): enables Nesterov momentum (default: False) Example: &gt;&gt;&gt; optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9) &gt;&gt;&gt; optimizer.zero_grad() &gt;&gt;&gt; loss_fn(model(input), target).backward() &gt;&gt;&gt; optimizer.step() \"\"\" 虚拟机后台训练只需要在以前训练的指令前增加 nohup 命令，同时在结尾加上 &amp; 符号即可： 12nohup python -m visdom.server &amp; # 后台运行visdom.servernohup python train.py &amp; # 使模型在后台训练 我们可以通过 jobs -l 来查看进程，在训练结束后通过 kill 指令关闭后台进程： 12jobs -l # 查看进程kill -9 PID # 通过进程的PID关闭进程 当终端链接断开，重新链接后无法通过 jobs 命令查看后台进程，此时需要通过 ps ux 指令查看所有的进程的 PID，然后通过 kill 指令关闭进程： 12ps ux # 查看所有进程的PIDkill -9 PID # 关闭特定进程 另外一点需要注意的时，通过后台运行程序的所有输入都会存储到 nohup.out 的文件中，如果不清理的话，该文件会不断增加，nohup.out 文件默认存放在当前执行脚本所在的目录中，也可以同过指令修改存放位置： 123456# 修改nohup.out文件存放位置nohup python train.py &gt; /path/to/custom.out &amp;# 在不停止进程的情况下清空nohup.out文件的指令（以下两个指令任选一个即可）cp /dev/null nohup.outcat /dev/null &gt; nohup.out 例如： 123456(fixmatch) root@be6fec86789a:~/Tz/FixMatch-pytorch# nohup python train.py --dataset cifar10 --num-labeled 4000 --arch wideresnet --batch-size 64 --lr 0.03 --expand-labels --seed 5 --out results/cifar10@4000.5 &gt; /root/Tz/FixMatch-pytorch/log/fixmatch_cifar10_4000_5.out &amp;[1] 3913nohup: ignoring input and redirecting stderr to stdout(fixmatch) root@be6fec86789a:~/Tz/FixMatch-pytorch# jobs -l[1]+ 3913 Running nohup python train.py --dataset cifar10 --num-labeled 4000 --arch wideresnet --batch-size 64 --lr 0.03 --expand-labels --seed 5 --out results/cifar10@4000.5 &gt; /root/Tz/FixMatch-pytorch/log/fixmatch_cifar10_4000_5.out &amp;","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://ytz7.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[]},{"title":"FixMatch","slug":"fixmatch","date":"2023-05-22T05:01:14.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/e378f85.html","link":"","permalink":"https://ytz7.github.io/posts/e378f85.html","excerpt":"","text":"Simplifying Semi-Supervised Learning with Consistency and Confidence 会议：NeurIPS 2020 论文地址：FixMatch: Simplifying Semi-Supervised Learning with Consistency and Confidence Pytorch 复现： kekmodel/FixMatch-pytorch CoinCheung/fixmatch-pytorch valencebond/FixMatch_pytorch: 参考文章： Semi-Supervised Learning in Computer Vision 主要工作FixMatch 结合了半监督学习之前的工作，结合伪标签（ pseudo-label）和 一致性正则（Consistency Regularization），并且它更简单，相较于之前在半监督学习的工作，比如：UDA 和 ReMixMatch，如下图所示，FixMatch 在有标签数据上训练，将预测所得到的概率分布与真实标签计算损失 L1； 对于无标签数据，FixMatch 做了两次数据增强，这是一个相较于其他工作特别的地方，FixMatch 分别对无标签数据做了弱增强（Weakly Augmented）和强增强（Strongly Augmented），对于弱增强后的数据通过模型预测得到一个概率分布，并且，对这一概率分布做一特殊处理，最概率分布中最大的概率，设置一个阈值，若该概率大于该阈值，那么则将其纳入损失函数之中，并且，使用 arg max使其分布变为 One-Hot形式，接着与强增强后的数据通过模型预测得到的分布作交叉熵得到损失L2，最后通过加权和得到最终的损失。 其中 L1、L2 以及最终的损失如下图所示： 这里提一下，在计算有标签数据，将对对其作一些弱增强的操作，一个很有意思的结果，对于权重系数 λ，在先前的工作中都显示对权重系数慢慢提升是一个很重要的部分，但在 FixMatch 中，提升权重系数这一部分以及包含在算法当中，就不需要额外进行一些计算将权重系数慢慢增大： 不需要添加这个权重系数的原因是：在损失函数中 max(qb)在早期训练中绝大部分数据通过模型预测得到的最大概率值都会比阈值τ小，在训练的过程中，模型的预测输出将会越来越“自信”，而将会有越来越多的数据样本的 max(qb) &gt; τ 。 数据增强方式弱增强（Weak Augmentation）论文中使用了简单的翻转和平移（flip-and-shift）策略： Random Horizontal Flip 随机水平翻转，论文中使用了设置其概率为 0.5，对于 SVHN 数据集不适用该增强方式，因为 SVHN 数据集为都是数字，对数字进行翻转，没有意义，以下是基于 Pytorch 实现： 12345from PIL import Imageimport torchvision.transforms as transformsim = Image.open('dog.png')weak_im = transforms.RandomHorizontalFlip(p=0.5)(im) Random Vertical and Horizontal Translation 12345678import torchvision.transforms as transformsfrom PIL import Imageim = Image.open('dog.png')resized_im = transforms.Resize(32)(im)translated = transforms.RandomCrop(size=32, padding=int(32*0.125), padding_mode='reflect')(resized_im) 强增强（Strong Augmentation）FixMatch 对数据样本运用了 RandAugment 和 CTAugment 后，在对其使用 CutOut 增强方式。 Cutout 1234567891011121314151617import torchimport torchvision.transforms as transforms# Image of 520*520im = torch.rand(3, 520, 520)# Fill cutout with gray colorgray_code = 127# ratio=(1, 1) to set aspect ratio of square# p=1 means probability is 1, so always apply cutout# scale=(0.01, 0.01) means we want to get cutout of 1% of image area# Hence: Cuts out gray square of 52*52cutout_im = transforms.RandomErasing(p=1, ratio=(1, 1), scale=(0.01, 0.01), value=gray_code)(im) AutoAugment RandAugment 后面两个增强方式具体还没有看他的论文，就不介绍了… 训练过程对有标签的数据使用的 Batch 大小为 B，对于无标签的数据所使用的 Batch 大小为 μB，其中 μ 为超参数，作者使用 μ = 7 用于模型的训练： 有监督学习部分，使用交叉熵计算损失函数： 对未标记数据制作伪标签： 计算一致性损失，所使用的损失函数也为交叉熵： 对于上述所提到的权重系数 λ，在训练过程中，应用与训练的无标签数据将会越来越多，如下图所示，模型就好像是小孩子学习一般，从简单在到复杂： 算法如下所示： 实验 在论文中，作者做了一个很有意思的实验，即只取 10 个有标签的数据（在 CIFAR-10 中，即每一个类别只取 1 张图片），作者随机挑选了 4 次，构建了 4 个不同的数据集，模型的准确率（中位数）为 64.28%（准确率范围为：48.58% - 85.32%）。 并且，训练数据集之间的差异并不是很大，理应得到的准确率应该相差不大，但作者发现了，4 个模型在第一个数据集中训练得到的准确率都达到了 61% - 67%，而在第二个数据集中准确率在 68% - 75%。 作者认为：训练的不稳定性与每个数据集中 10 个标记数据的质量有关，采样得到的低质量的标记数据，可能会让模型很难有效的学习信息，为了验证这一个观点，作者构建了 8 个新的训练数据集（各个类别中最有代表性的有标签数据 -&gt; … -&gt; 各个类别中最没有代表性的有标签数据）进行训练，结果如下图所示： 结果和假设一样，基于最有代表性的有标签数据组成的数据集训练达到了 78% 的准确率，而最没有代表性的有标签数据则为 10%，因此，可以验证，标记数据的质量好坏决定了模型的好坏。 消融实验由于 FixMatch 模型很简单，很容易就能实现（指代码量少），作者对与先前的工作未提到的 优化器（Optimizer）和 学习率更新的方式（ Learning Rate Schedule）花了很多的功夫研究。 Ablation Study on Optimizer 作者在实验中发现：不同的优化器以及优化器中超参数的选择对性能有着很大的影响，并且，Adam 的性能并不比 momentum SGD 好，原因可能在于模型对于学习率的变化很敏感，如下图所示： Ablation Study on Learning Rate Schedule上文中所提到，作者发现模型对于学习率的变化很敏感，作者发现，在选择合适的衰减方式的同时，选择合适的衰减率也很重要： 总结以上是我觉得比较有意思的地方，具体可细看论文。","categories":[{"name":"半监督学习","slug":"半监督学习","permalink":"https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Semi-Surprised-Learning","slug":"Semi-Surprised-Learning","permalink":"https://ytz7.github.io/tags/Semi-Surprised-Learning/"},{"name":"机器学习","slug":"机器学习","permalink":"https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Hybrid Methods","slug":"Hybrid-Methods","permalink":"https://ytz7.github.io/tags/Hybrid-Methods/"}]},{"title":"Unsupervised-Data-Augmentation","slug":"Unsupervised-Data-Augmentation","date":"2023-05-18T10:55:32.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/77eb0ac8.html","link":"","permalink":"https://ytz7.github.io/posts/77eb0ac8.html","excerpt":"","text":"Unsupervised Data Augmentation for Consistency Training 会议：NeurIPS 2019 论文地址： Unsupervised Data Augmentation for Consistency Training Pytorch 复现：sndnyang/vat_pytorch 参考文章： Semi-Supervised Learning in Computer Vision 码侯烧酒的博客 Unsupervised Data Augmentation for Consistency Training 参考视频： 数最后一名 动机最近的半监督学习方式都是基于一致性学习（consistency training）的，尽管成果不错，但是它们添加噪声的方式都比较初级，大多数都是基于 Gaussian noise， dropout noise 或者是 adversarial noise。因此，作者想引入一些更高级的数据增强方式，尤其是那些在监督学习中已经证明有效的方法，看看它们在半监督学习中是否也是有效的。 目标少样本标注情况下，充分利用无标注数据，使其尽可能达到有充分标注的效果。 思路根据一致性训练的原则，认为对一个样本进行较好的数据增强后，预测标签不应该发生变化，因此一般来说会有两个部分的 loss：（1）标注样本的损失，一般采用交叉熵；（2）未标注样本的损失，KL 散度等。 流程图如下所示，对有标签样本计算损失 L1，对无标签样本执行一次预测得到一个结果，再对改变本做一次特殊的数据增强后在进行预测得到一个结果，将两个结果计算一致性损失 L2，将 L1 与 L2 计算加权和。 数学形式说明该流程，输入 x，计算输入分布 p_θ(y|x) 和带噪声的分布 p_θ(y|x, ɛ)，然后最小化两个分布之间的距离： 上述图片对应的损失函数如下所示： 其中，λ 为平衡有监督学习和一致性训练之间的损失，CE 为交叉熵，f*(.) 为索要训练的最终目标模型。 但有一点很奇怪，作者在之前的版本中计算一致性损失所采用的计量方式为 KL 散度，但是在最新版本又换回了 Cross-Entropy，不懂这是为什么…可能看效果而异吧。 不过有的人说： MSE 和 KL 散度各有优劣，二者的选取与数据集的实际分布特征关系很大，在实践中不妨进行对比测试 在论文中，作者正对计算机视觉和自然语言任务提出了不同的对应增强方法，其中对于图片的增强方式，作者使用了一个增强方法 RandAugment，（只了解了大概，具体论文没看，好像是从强化学习中的 AutoAugment 衍生而来的）。不同任务的效果如下所示： 训练技巧（Tricks）数据层面 基于置信度的掩码（Confidence-based masking） 对预测效果不好的样本（指针对一致性预测的原始样本），即置信度（最大的样本的概率）小于一定阈值数据，不计入一致性损失。 输出分布锐化（Sharpening Predictions） 降低预测结果的熵对训练有好处，所以作者对无标签的预测见过做锐化，采用的方法为 low Softmax temperature τ，与方法一相结合，在 batch 大小为 B 的情况下，损失为： 域外相关数据的选择（Domain-relevance Data Filtering） 无标签数据量大，其中的数据分布往往是不均衡且有大量任务无关数据，为了解决这个问题，论文提出一种通用的无标签数据分布均衡化策略。首先利用有标签数据训练一个初始化模型，然后去预测所有无标签数据，根据置信度均衡选择各类别数据。 训练层面Training Signal Annealing（训练信号退火） 主要是针对标签数据与未标签数据不平衡时的场景，由于有大量的未标签数据需要UDA 处理，所以需要一个较大模型，但是由于较大模型很容易在少量标签数据下过拟合，所以，提出了本方法用于解决该问题。 基本原理就是在训练过程中，随着未标签数据的增加，逐步去除带标签数据，从而避免模型过拟合到带标签的训练数据。具体而言，就是在训练的 t 时刻，设置一个阈值 ηt，当 1/K ≤ ηt ≤ 1，其中，K 是类别数，当某个标签数据计算的 p_θ(y∗| x)大于阈值ηt，将该标签数据移除出计算损失的过程，而只计算 miniBatch 里面的其余数据。 具体策略有 3 种： log-schedule linear-schedule exp-schedule 对于 labeled 数据量少，容易过拟合情况，选择最后一种；对于 labeled 数据量较多，过拟合不严重，可视情况选择前两种。 理论方面的探讨（Theoretical Analysis） 理论渣渣只能意会不可用文字整理出来，具体看论文吧… 总结给人的感觉这一篇好“工程”😂，在数据方面做了很多文章，但半监督领域又好像都是在对数据这一方面做很多“动作”，不管了，接着看，接着读。","categories":[{"name":"半监督学习","slug":"半监督学习","permalink":"https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Semi-Surprised-Learning","slug":"Semi-Surprised-Learning","permalink":"https://ytz7.github.io/tags/Semi-Surprised-Learning/"},{"name":"机器学习","slug":"机器学习","permalink":"https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Data Augmentation","slug":"Data-Augmentation","permalink":"https://ytz7.github.io/tags/Data-Augmentation/"},{"name":"Consistency Regularization","slug":"Consistency-Regularization","permalink":"https://ytz7.github.io/tags/Consistency-Regularization/"}]},{"title":"Virtual Adversarial Training","slug":"Virtual-Adversarial-Training","date":"2023-05-17T11:50:25.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/cc87ae2e.html","link":"","permalink":"https://ytz7.github.io/posts/cc87ae2e.html","excerpt":"","text":"A Regularization Method for Supervised and Semi-Supervised Learning 期刊：IEEE Transactions on Pattern Analysis and Machine Intelligence (2018) 论文地址： Virtual Adversarial Training Pytorch 复现：sndnyang/vat_pytorch 参考文章： Semi-Supervised Learning in Computer Vision 码侯烧酒的博客 Facico的博客 参考视频： 数最后一名 主要思想论文的关键想法同样保持着一致性正则化的思想，只不过将图像的增强方式以生成对抗样本（Adversarial Example）来代替之，有标签的损失采用交叉熵（Cross-Entropy）计算，无标签的损失使用 KL 散度（KL Divergence）来计算，最后施以对应的权重得到最终的损失，大致流程图如下所示： 一致性正则化具体来说，基于平滑假设和聚类假设，具有不同标签的数据点在低密度区域分离，并且相似的数据点具有相似的输出。如果对一个未标记的数据应用实际的扰动，其预测结果不应该发生显著变化，也就是输出具有一致性。其数学表达如下： 其中，D 为度量函数，一般采用 KL 散度 或者 JS 散度，当然也可以使用交叉熵或者平方误差等，Augment(·) 是指数据增强函数，当采用数据增强是，视为对样本/模型添加一些噪声扰动，θ 为模型参数。 常见的数据增强有以下： 常规的数据增强：平移旋转，随机 dropout等 时序移动平均：Temporal Ensembling，Mean-Teacher 中使用的方法 对抗样本扰动：VAT 高级数据增强：UDA 对抗训练对抗训练（Adversarial Training）是增强神经网络鲁棒性的重要方式，在对抗训练的过程中，样本会被混合一些微小的扰动（哪怕改变很小，但很有可能会造成错误分类），使神经网络适应这种改变，从而对对抗样本具有鲁棒性。 生成对抗样本有以下几种常见方式： 基于梯度法: Explaining and Harnessing Adversarial Examples 基于超平面分类: DeepFool: a simple and accurate method to fool deep neural networks 对抗攻击（Adversarial Attack）：在模型原始输入上添加对抗扰动 Goodfellow 对对抗训练损失函数定义如下： 其中，D 是衡量两个分布相似度的函数，q(y|xl) 是样本的真实分布，p(y|xl, θ) 是由参数和 xl 生成的预测分布，通过增加扰动 radv 来使得两个分布尽量相似。 对抗为什么可行？ 因为很多网络被设计得十分“线性”，像 LSTM 这样的，对x的每个维度都做微小扰动，当x的维度变大的时候，会对网络造成较大的影响 网络的线性，使得高阶导近似0，Taylor 展开后占主导的是线性的部分，所以用来干扰的主要就是对抗样本中线性的部分 通常，我们无法获得精确对抗性扰动的闭式解，不过可以通过上式中的度量 D 来线性近似 r，使用 L2 正则是，对抗扰动可以通过下面的式子近似： 使用 L∞ 正则时，可通过下面的式子近似： 其中 g 为： 可通过反向传播进行计算，对抗方法得到的扰动方向，比随机找一个扰动更好。 对抗训练存在的缺点：仅仅只能适配于有监督学习，当样本没有标签就不能进行，故作者提出了一种可以运用于半监督学习的对抗训练方法。 Virtual Adversarial Training, VATAdversarial Direction，对抗性方向，其概念是指能够最大程度减少准确分类的概率的方向，如下图所示，寻找扰动项 radv，其投影点与准确分类的方向为对抗性方向。 local distributional smoothness（LDS），定义为衡量当前基于每个输入数据的模型的平滑度的负函数。 推导流程 由于不知道为什么公式渲染不出来，我就不手打公式了，等有时间再去把这个问题弄了，我就直接套用现成已有的公式，或是直接手写出来，Sorry… 文中的符号定义如下： 在上面，我们提到，对抗训练只适用于带标签的有监督问题，在半监督学习中并不是很适用，所以，作者就提出了虚拟对抗训练，VAT 的损失函数如下： 其中，x⁎可以表示为有标签或者无标签数据，正如上文中所提到的，在实际中，并没有关于 q(y, xul) 的直接信息，因此可以使用p(y|x, θ)来替换之，如果带标签的样本比较多时，p就会逼近q，利用p生成的虚拟标签代替不知道的标签，并根据虚拟标签计算对抗方向，此时的虚拟标签是用上一步训练之后得到的模型进行估计，故损失函数更新如下： 将损失函数求平均，得到正则项（regularization term）： 完整的目标函数为： 其中第一项为带标签数据的负对数似然函数（针对有标签数据），VAT 的一个优点是：只有两个超参数：（1）对抗方向的限制参数（norm constraint）ɛ &gt; 0；（2）控制目标函数的两个目标项的相对平衡的正则化系数（regularization coefficient）α &gt; 0，事实上，作者指出，两个超参数的作用大抵相同，于是 VAT 中只微调了超参数 ɛ，而将 α 固定为 1。 对于上述目标函数，观察到，当 r = 0 时，D 永远为 0，所以需要对 D 进行二阶泰勒展开，这里的 D 为： 二阶展开后得到： 其中 H 为海森矩阵（Hessian Matrix），具体如下： 故 rvadv 可以近似为： 其中：u 是 H 的第一特征主向量，上划线表示同方向单位向量（算了我写出来.） 在计算 H 的特征值/特征向量时，时间复杂度需要 O(I³)，论文中提到使用幂迭代法（ power iteration method）和有限差分法（finite difference method）来近似求解，假设 d 为与特征向量不垂直的一个随机单位向量，迭代计算如下： 注意到 Hd 可以被有限差分来近似计算： 由于 D 的一介导还是很可能为 0，所以 r 用如下方式迭代更新： 迭代的次数越多效果越好，甚至很多数据集上迭代次数为 1 都取得了较好的效果，迭代次数如下： 伪代码如下： 效果如下所示： 迭代次数较少的情况下，有大量的未标记点（灰色点）会有较高的LDS（深蓝色），即不平滑，因为模型一开始对相同类别的 point 预测了不同的 label，VAT 会让 LDS 较高的数据点更大的压力，使得数据点间边界更平滑。 总结文章的亮点就是对于二阶导以及之后的各种近似优化，理论方面很充足，实验也很充足，理论方面对于我这个渣硕来说真的挺艰难，我在去年 12 月份就准备看这一篇，结果因为理论被劝退，终于时隔数月，我算是啃下来了…不过也还是云里雾里的，还是得补充一下数学理论知识啊，果然我导说的没错，理论知识都不懂，给我发论文看我都看不懂，那还搞啥呢，哈哈🤦‍♂️，就这样子，如果有机会再复盘这篇论文，有问题在更新。 最后附上我得手写版公式（惨不忍睹的被公式薄纱了）：","categories":[{"name":"半监督学习","slug":"半监督学习","permalink":"https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Semi-Surprised-Learning","slug":"Semi-Surprised-Learning","permalink":"https://ytz7.github.io/tags/Semi-Surprised-Learning/"},{"name":"机器学习","slug":"机器学习","permalink":"https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Consistency Regularization","slug":"Consistency-Regularization","permalink":"https://ytz7.github.io/tags/Consistency-Regularization/"},{"name":"Adversarial Example","slug":"Adversarial-Example","permalink":"https://ytz7.github.io/tags/Adversarial-Example/"}]},{"title":"关于深度学习中遇到的知识盲区","slug":"deep-learning-some-questions","date":"2023-05-11T11:47:01.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/eaa3f406.html","link":"","permalink":"https://ytz7.github.io/posts/eaa3f406.html","excerpt":"","text":"关于深度学习的一些问题与知识盲区此篇用于记录在阅读论文以及博客时遇到的一些问题和知识盲区，方便日后进行复盘。 激活函数为什么需要激活函数？通常激活函数都是非线性的，它能够帮助我们引入非线性因素，使得神经网络能够更好地解决更加复杂地问题，在简单的二分类问题中，如果不使用激活函数，使用简单的**逻辑回归**，那么该模型只能作简单的线性分类，而不能作复杂的非线性划分，如下图所示： 值得一提的是，如果所有的隐藏层全部使用线性激活函数，只有输出层使用非线性激活函数，那么整个神经网络的结构就类似于一个简单的逻辑回归模型，效果与单个神经元无异。另外，如果是拟合问题而不是分类问题，输出层的激活函数可以使用线性函数。 Sigmoid 函数饱和带来的问题Sigmoid 函数的取值范围在 (0,1) 之间，单调连续，求导容易，一般用于二分类神经网络的输出层。 Sigmoid 函数饱和区范围广，容易造成梯度消失。饱和区如下图所示，图中红色椭圆标注的饱和区曲线平缓，梯度的值很小，近似为零，且 Sigmoid 函数的饱和区范围很广，除了 [-5,5]，其余区域都可以认为是饱和区，这种情况很容易造成梯度消失，梯度消失会增大神经网络训练难度，影响神经网络模型的性能。 降噪自编码器 Denoising Auto-Encoder在神经网络模型训练阶段开始前，通过 Auto-encoder 对模型进行预训练可确定编码器 W 的初始参数值。然而，受模型复杂度、训练集数据量以及数据噪音等问题的影响，通过 Auto-encoder 得到的初始模型往往存在过拟合的风险。 简单理解，在人类的感知过程中，某些模态的信息对结果的判断影响并不大。举个例子，一块圆形的饼干和一块方形的饼干，在认知中同属于饼干这一类，因此形状对我们判断是否是饼干没有太大作用，也就是噪声。如果不能将形状数据去除掉，可能会产生“圆饼干是饼干，方饼干就不是饼干”的问题（过拟合）。 当采用无监督的方法分层预训练深度网络的权值时，为了学习到较鲁棒的特征，可以**在网络的可视层（即数据的输入层）引入随机噪声**，这种方法称为降噪自编码器（Denoising Auto-Encoder， DAE）。 降噪自编码器：一个模型，能够从有噪音的原始数据作为输入，而能够恢复出真正的原始数据。这样的模型，更具有鲁棒性。 以下是以经典的 MNIST 手写数字识别为例，对于输入的数据引入了变换角度、随机噪点、添加背景图像等噪音。模型通过训练后可以对有噪音图像更加鲁棒，而这也更符合实际使用的需求。 对于有噪音的输入数据，区别于一般自编码机，降噪自编码机要做的就是数据的降噪。关于降噪的过程如下图所示： 对于输入层 $x$，以一定概率将其节点置 0，得到 $\\hat{x}$,用 $\\hat{x}$ 去计算 $y$,计算 $z$ ，并将 $z$ 与原始 $x$ 做误差迭代，对结果误差较小的节点可以认为是噪声。每层处理重复上述工作。 自编码器的本质是学习一个相等函数，即网络的输入和重构后的输出相等，这种相等函数的表示有个缺点就是当测试样本和训练样本不符合同一分布，效果不好，而降噪自编码器在这方面的处理有所进步。 随机深度 Stochastic Depth针对于残差模块的优化，由于很深的 ResNet 通常需要很长时间的训练(也就是训练很慢)，作者引入了一种类似于 dropout 的方法，在训练过程中随机丢弃子图层（randomly drop a subset of layers），而在推断时正常使用完整的图。 ResNet 网络是由一个接一个的残差模块(ResBlock)串联起来的，可以视为ResBlock的集合。在训练时，对每个 ResBlock 随机 drop（按伯努利分布），drop 就是将上一个 ResBlock 直接输出到下一个 ResBlock，被 drop 的 ResBlock 什么都不做也不更新。另外，网络的输入被视为第一层，是不会 drop 的。 与 Dropout 的不同之处在于，该方法 drop 整个 ResBlock，而 Dropout 在训练期间只 drop 一部分神经元节点。这种方法大大降低了训练时间，甚至在训练完成后删除部分layer，还能不影响精度。 最小化信息熵 Entropy Minimization参考文章：最小熵原理（一） 在半监督学习中，有标签（分类完全准确）的数据样本通常相对较少，通过训练模型对未标记数据样本进行预测，选择出高置信度的样本，作为标记样本同有标签样本作为下一次训练的数据样本。 Entropy Minimization 是一种在半监督学习中使用的技术，它的目的是最小化信息熵，从而使模型在分类时的不确定性最小。在半监督学习中，我们希望模型尽可能地利用未标记数据来学习，但是这些数据并不带有正确的标签，因此我们需要利用某些技术来帮助我们学习这些数据。 加快模型学习进度的唯一方法就是降低学习目标的冗余信息量，所提到的“去冗余”，可以理解为“省去没必要的学习成本”。 也就是通常所使用到的技巧：过滤掉低置信度的未标记样本，保留高置信度样本。 Top-1 and Top-5 AccuracyTop-1： 在多分类问题中，一般认为在经过全连接层后得到的概率分布中概率最大的类别为我们模型的预测类别，就判断为正确。 Top-5： 在多分类问题中，一般认为在经过全连接层后得到的概率分布中概率最大的全五个类别中有我们模型的预测类别，就判断为正确。 Dark Knowledge可以看作是经过 Softmax 函数后得到的各类类别的可能性，其包含着类别之间的相关性，比如，猫和狗的相似性，要远远大于猫和船的相似性，而这种相似性，会在概率值中有所体现，而这部分信息一致没有被很好的利用，所以称之为 Dark Knowledge。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://ytz7.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://ytz7.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"半监督学习学习过程","slug":"semi-suprised-learning-start","date":"2023-05-11T07:08:40.000Z","updated":"2023-09-13T09:03:09.924Z","comments":true,"path":"posts/52ee1a8c.html","link":"","permalink":"https://ytz7.github.io/posts/52ee1a8c.html","excerpt":"","text":"半监督学习写在前面学习了快一个学期的 Java 程序开发，让我感觉开发的过程真的好空洞…但是我并不知道下一步到底要做什么，又处于想找实习又怕找不到的情况下，刷了几天 LeetCode，然后又变成了“小🐏人”，紧接着被隔离😅，真的挺痛苦，所幸在第三天就“出狱”了，在蹲“监狱”期间，受到一个“狱友”的启发，“还是要做好职业规划的，若是没有做好职业规划，像一只无头苍蝇一样，很可能在毕业之际还是找不到工作。”在思考了一天后，我决定重新开始在“半监督学习”这个领域开始零基础学习了，为什么会有这个想法？是因为我觉得我起初考研的目的是为了能够在人工智能这个领域继续深入了解，目的很单纯，那为什么我不坚持一下呢？于是我决定重新开始这个计划，管他呢，起码是自己喜欢做的事情，哪怕未来找不到工作什么的，起码现在是由试错的资本的。 以下将会记录我在学习时候遇到的问题/解决方式/新思路/感想。 Self-Training自训练方法，模型基于已标记好的训练集进行训练，得到一个基础模型，利用该基础模型对未标记的数据集进行预测一个伪标签，然后将两个数据集整合训练，得到一个新的模型，从而迭代更新模型参数，生成一个最优模型。 Pseudo-Label伪标签技术适用于小样本学习，实际上在样本极其珍贵的金融、医疗图像、安全等领域，伪标签学习有时候很有效。 伪标签的定义来自于半监督学习，半监督学习的核心思想是通过借助无标签的数据来提升有监督过程中的模型性能。 粗略来讲，伪标签技术就是利用在已标注数据所训练的模型在未标注的数据上进行预测，根据预测结果对样本进行筛选，再次输入模型中进行训练的一个过程。 如下图所示，利用有标签的数据集训练出一个模型，运用训练出的模型给予无标签数据一个伪标签。如何定义所属类别？利用训练好的模型对无标签数据进行预测，以概率最高的类别作为无标签数据的伪标签。 entropy regularization：用于防止模型过拟合，通过在损失函数中加入熵（entropy）项来实现 利用 entropy regularization 思想，将无监督数据转为目标数据的正则项，即将拥有伪标签的无标签数据视为有标签的数据，利用交叉熵（与最初训练模型一致）来评估误差大小。 模型整体的目标函数如下： 其中左边一项为交叉熵，用来评估有标签数据的误差，右边一项即为 entropy regularization 项，用来从无标签的数据中获取训练信号。 为了平衡有标签数据和无标签数据的信号强度，如上所示，算法在目标函数中引入了时变参数 α(t)，其数学形式如下，其中 T1 和 T2 都为超参数： 因此，随着训练时间的增加，α(t) 将会从零开始线性增长至某个饱和值，对应无标签数据的信号也将逐渐释放出来。背后的核心想法也很直观，早期模型预测效果不佳，因此 entropy regularization 产生信号的误差也较大，因而 α(t) 应该从零开始，由小逐渐增大。 存在不足：只在训练时间这个维度上，采用了退火思想，即采用时变系数α(t)。而在伪标签这个维度，对于模型给予的预测标签一视同仁，这种方法在实际中存在明显问题。若模型在对伪标签的数据预测后， 10 个类别预测概率值都接近于 0.1，以最大概率这一原则选择对应的标签，那么这个标签对模型的训练会造成一定的副作用。 设想如何突破这一不足？ 也许可以设定一个阈值，抛弃那些预测最大概率值小于该阈值的未标记样本，将满足条件的未标记样本分配伪标签，并加入模型评估当中，之后再迭代训练。 Noisy Student论文的关键 idea 是训练两个模型，“teacher”和“student”，强调的是在student模型中加入噪声，teacher 模型和 student 模型可以用不同的模型训练，也可以使用相同的模型。 在有标签数据中训练“teacher”模型，并利用该模型对未标记数据进行推断伪标签，这些伪标签可以是软标签，也可以取其最大概率的类别将其转换为硬标签。 然后将标记数据与为标记数据（带有伪标签）置入“student”进行训练，在训练之前数据增强使用 RandAugment，待“student”模型训练好后，使用最新的模型作为新的“teacher”，进行下一次迭代，此过程会重复几次（通常为 3 次）。 总结该篇论文的流程思路： 首先将在 ImageNet 上训练好的模型作为 Teacher Network 来训练 Student Network 再使用训练好的 T 网络（无噪音）来对另一个数据集 [JFT dataset] 生成尽可能准确的伪标签 之后使用生成伪标签的数据集 [JFT dataset] 和 ImageNet 一起训练 Student Network Student Network中增加了模型噪音 Dropout 随机深度 Stochastic Depth 数据噪音：对图片进行数据增广（RandAugment） 对 Student 模型添加噪音的作用： 数据噪音：提高泛化能力 模型噪音：提高模型鲁棒性和泛化能力 具体参数设置： Stochastic Depth：幸存概率因子为 0.8 Dropout：分类层（final layer）引入 0.5 的丢弃率 RandAugment：应用两个随机计算，其震级设置为 27 其他 Tricks： 数据过滤：将教师模型中置信度不高的图片过滤，因为这通常代表着域外图像（out-of-domain data） 数据平衡：平衡不同类别的图片数量，当一个类别所对应的图片数量不是很充足时，会采取随机复制的方法来扩充样本量 软标签（Soft Pseudo-Label）：在消融实验中表示，软标签对域外图像有更强的指导作用 消融实验1.噪音是否对模型有影响？（The Importance of Noise in Self-training） 从结果可以看出，噪音、随机深度、数据扩充起着重要的作用使学生模型胜过教师模型，对此有人提出是不是对未标记数据加入正则项以防止过拟合来代替噪音，作者在实验中说明这是不对的。因为在去噪的情况下，未标记图像的训练损失并没有下降多少以此说明模型并没有对未标记数据过拟合。 2.对于迭代训练的消融实验（A Study of Iterative Training） 作者先在标记数据上训练了 EfficientNet-B7 作为 Teacher，然后再训练 EfficientNet-L2 作为 Student，然后让 Student 作为 Teacher 依次迭代三轮，作者表明，迭代训练提高了准确度，并且，给出再最后通过调整未标记图像和标记图像的比为 1 : 28 时达到最优 Top-1 Acc.。 3.能力强的教师模型会不会对学生模型造成的影响 4.无标签的数据量大小 作者按照比例分别从整个数据集中均匀采样（uniformly sampling），会发现在数据量减少至 1/16 中，模型的性能大都相似，在数据量达到 1/32 或更小后，模型性能有了显著的下降（可能 .3 个点就可以算是显著的下降了吧…），所以，使用大量未标记的数据会产生更好的性能，但作者指出：对于大模型来说，数据量越多越好，而小模型由于容量限制则很容易饱和。 5.硬标签和软标签对域外图像的影响 作者将预测置信度高（high-confidence）的图像视作域内图像（in-domain images），反之，将预测置信度低（low-confidence）的图像视作域外图像（out-of-domain images），作者表明：对于域内图像，软伪标签（ soft pseudo labels）和硬伪标签（hard pseudo labels）都对模型有一定的帮助；而对于域外图像，软伪标签使得模型对域外图像的判断有着一定的帮助，而硬标签则会对模型的精度有一定的损害。 剩下的消融实验就不写了，有点过于冗长了。 Consistency Regularization说到一致（Consistency），其实很多代价都有这个内涵，如 MSE 代价，最小化预测与标签的差值，也就是希望预测与标签能够一致。其他的代价，如 KL 散度、交叉熵代价也类似。 所以一致性，是一种非常内在而本质的目标，可以让深度网络进行有效学习。 在半监督领域中，未标记数据没有标签，所以需要让模型有个参照，从而通过这个参照从未标记数据中学习。 Consistency Regularization 的主要思想是：相同的一张图片，通过模型所预测出来的结果应该是一样的。对于未标记样本，虽然没有对应的标签来使得模型判断预测结果是否准确，但是，却可以在原有的样本中添加一定的噪声，让模型通过比对预测结果来进行学习。 π-model and Temporal Ensembling论文地址：Temporal Ensembling for Semi-Supervised Learning π-model如下图所示，一个有标签样本（可视作无标签样本），经过随机图像增强输入网络，同时网络也会进行 Dropout 也可以视作噪声，输入两次得到两个结果 Z 和 Z’，将 Z 与图片真正标签 y 进行比对，使用 交叉熵（cross-entropy）计算损失 L1；将 Z 与 Z’ 使用 平方差（squared difference）计算损失 L2，然后将两个过程所得到的损失相加，但需要注意的是，两个损失分别占有一定权重，且占有的权重值会随着训练时间改变，在图 2 的所标记的损失函数公式可以看出。 其中 C 表示标记样本的的全部类别数量，w(t) 是随时间变化的加权函数， 并且，作者指出，第一部分的损失只针对有标签数据进行计算，而第二部分的损失则针对所有数据进行计算，即在算损失的时候，有标签数据两个损失项都用，无标签数据只用第二个损失项： 作者指出，使用 w(t) 时，由于前期模型差不多被有监督损失部分（标记数据样本）所支配，所以，在增长的前期，使权重增长的尽可能慢一点。 总结流程就是，数据集：有标签/无标签图片，分别两次输入模型，其中，L1只在有标签数据参与训练的过程中用于计算损失，L2 则是都有参与计算损失（有标签和无标签）。模型的噪音来自于：输入图像的随机增强，以及模型训练过程中的 Dropout。计算损失公式：L1 使用交叉熵来计算损失，L2 使用平方差公式来计算损失。 Temporal Ensembling由于以这种方式获得的培训目标是基于对网络的单一评估，因此可以预期它们会很嘈杂。暂时性结合通过将多个先前网络评估的预测汇总为整体预测来减轻这种情况 在 π-model 中，模型的训练结果都只是对网络进行单一评估，预测结果没有很强的关联性，这样子就造成了模型变得很“嘈杂”，并且，直觉认为，很难不相信过去预测结果与现在的预测结果不存在联系，这就是 π-model 的缺点。 在 Temporal Ensembling 中就很好的解决了这一个问题，在计算第二部分的损失中，生成的 Z’ 要参与下一个 epoch 的损失计算，（注意是每一个 epoch，而不是每一个 batch，这种改变其实是非常缓慢）。 每训练完一个 epoch 后，就会将 Z 进行更新： 总结流程，不同于 π-model，Temporal Ensembling 只进行一次模型预测，π-model 中的第二次训练预测，前一个 epoch 保存下来的 Z 与当前 epoch 的 z 进行指数滑动平均（Exponential Moving Average，EMA）运算得到，其中 z’ 是当前 epoch 的模型预测，参与 L2 的损失计算。 Mean Teacher论文的关键思想是使用两个模型一个叫做Student，另一个叫做Teacher，其中Student 模型是一个带有 Dropout 的标准网络模型，与上文中所提到的 Noise Student 不同的是，该篇论文中的 Teacher 模型的架构与 Student 模型一致，且更新参数时是由 Student 模型的参数作指数滑动平均计算得到。计算损失的方式与 Temporal Ensembling相似/一致，有标签数据使用两个损失项，而无标签数据使用 Student 和 Teacher 模型得到的结果计算一致性损失，最后模型的总损失是由两个部分的损失得到。 使用指数滑动平均来更新参数后，模型可以在每一个 step 而不是在每一个 epoch来聚合信息，这大大提高了推断效率。并且，模型的每一层输出都得到了提升，而不是仅仅是在最后一层输出结果上得到改善，所以运用指数滑动平均，使得目标模型有了更好的中间表示（intermediate representations）。 Teacher 模型参数 θ 的更新公式如下所示，在论文中将模型参数 θ 视作常量，不参与模型训练更新，而是在每一个 step 中按照公式进行迭代更新。 使用三种类型的噪声： 对输入图像输入图像作随机平移和水平翻转 Translation Randomly {∆x, ∆y} ∼ [−2, 2] Horizontal flip Randomly p = 0.5 Gaussian noise on the input layer Gaussian noise σ = 0.15 Dropout Dropout p = 0.5 并且，计算一致性损失（ consistency cost）与上述所提到的模型不同，使用的是均方误差(mean squared error)， 所使用的初始网络框架为： Virtual Adversarial Training由于有相关公式推导，且篇幅可能会很长（这篇论文理论部分好多…），故单独放在另一篇博客中。 Unsupervised Data Augmentation该篇论文的关键 idea 是使用 AutoAugment 创建一个未标记的图像的增强版本，使用最小化无标签数据增广数据和无标签数据的 KL 散度，如下图所示，具体思想和半监督学习中其他论文所使用的方法很相似，新鲜点就是论文的增强方式，对待不同任务使用不同的增强方式，且效果都还不错。 具体细节可查阅博客。 520 这天还在工位，真实咸鱼一条了 (#｀-_ゝ-) ，但今天见证历史了额，居然不看题解 LeetCode AC 了一道困难题，哈哈哈😊，然后就奖励了自己看一下午的视频（堕落了一下午），shit… 看论文看论文~~ 混合方法（Hybrid Methods）看名字就知道，混合混合，就是把前人所提出的一些方法就行合并，以及添加一些其他组件来提高性能。 MixMatch主要工作是在生成数据上做了很大的功夫，但感觉还是很工程…生成数据的算法如下所示： 对于有标签的数据，对其作一次增强，对于无标签的数据，对其作 K 个不同的增强，生成 K 个对应增强后的数据，并且对 K 个生成后的无标签数据做预测，预测后将其预测分布取平均后的分布作一次锐化，，作为 K 个无标签数据的对应分布，或者可以称之为最终的伪标签。 得到有标签数据增强后的结果 X^(x, p)，和无标签数据生成后带有伪标签的数据U^(u, q)，过程如下所示： 然后将增强后的数据 X 和 U 混合后做一次 Shuffle，得到样本集 W，其中前 N 项作为 W_L，剩余的 M 项为 W_U： 锐化公式如下图所示： 然后将 MixUp 算法运用在上述集合之中，作以下操作： 其中 MixUp 算法为图像增强算法，将两个图像按下面的公式生成新的图像： 为了让 MixUp 方法与损失项更兼容，作者对其做了一点小小的修改： 损失函数如下所示： 输入：相同 batch 大小有标签数据 X 和无标签数据 U 其中 T，K，α 为模型的超参数，α 在 MixUp 中需要使用，T 在锐化中使用到， K 为 K 个不同的数据增强方法： 输出：增强后的结果 X' 和 U' 然后计算有标签数据的损失 L_X，其中 H 为交叉熵，无标签数据的损失 L_U，使用 L2 损失，其中，无标签数据的损失项中 L 是总的标签数量（也就是输入的标签的维度）： 最后，将有标签数据的损失和无标签数据的损失合并，得到最终的损失，其中无监督的损失会对其施加一个权重 λ_U。 消融实验的结果： OK，按照这个博主关于半监督学习的综述，终于到达最后一篇经典论文了，不过有件事情一直想吐槽，就是 tensorflow 1. 怎么那么难用啊，本来说想复现一下 MixMatch 的实验，今天捣鼓了一整个下午，还是没有成功，气死我了，后面说是和 Cuda 的版本有冲突，tensorflow 1.15 的版本只能用 Cuda 10. ，服务器上又是 11. 的版本，奈何公共服务器都是大家一起用的，我怕搞得服务器崩了…索性算了，看下一篇去了，以后找论文源码的时候，应该要先找 Pytorch 版本的，不然搞这 tensorflow 又要浪费不少时间。 算了今天先不写了，会去跑步加和爸妈打打电话吧… 写于 2023/5/21. 就写了个开头 😂😅 FixMatch论文的方法是将先前所提到的伪标签（pseudo-labeling）和一致性正则化（consistency regularization）结合在一起，但又大大简化了整体方法，如下图所示，使用交叉熵在有标签数据上训练一个模型，损失记为 L1，对每一张未标记数据，做一次弱弱增强和强增强，对弱增强后的样本做预测，如果预测出的最大概率大于设置的阈值，那么将这个最大概率对于的类别作为弱增强后的样本的伪标签，即最后的输出分布为 One-Hot 编码，然后将弱增强和强增强的无标签数据对应的标签做一次交叉熵，得到损失 L2，最后将两个损失加权得到最终的损失 L。 算法步骤： 具体细节可查阅博客。","categories":[{"name":"半监督学习","slug":"半监督学习","permalink":"https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Semi-Surprised-Learning","slug":"Semi-Surprised-Learning","permalink":"https://ytz7.github.io/tags/Semi-Surprised-Learning/"},{"name":"机器学习","slug":"机器学习","permalink":"https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"个人随笔","slug":"个人随笔","permalink":"https://ytz7.github.io/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"半监督学习","slug":"半监督学习","permalink":"https://ytz7.github.io/categories/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"name":"环境配置","slug":"环境配置","permalink":"https://ytz7.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"目标检测","slug":"目标检测","permalink":"https://ytz7.github.io/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"},{"name":"学习计划","slug":"学习计划","permalink":"https://ytz7.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"深度学习","slug":"深度学习","permalink":"https://ytz7.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Semi-Surprised-Learning","slug":"Semi-Surprised-Learning","permalink":"https://ytz7.github.io/tags/Semi-Surprised-Learning/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://ytz7.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://ytz7.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Object-Detection","slug":"Object-Detection","permalink":"https://ytz7.github.io/tags/Object-Detection/"},{"name":"Hybrid Methods","slug":"Hybrid-Methods","permalink":"https://ytz7.github.io/tags/Hybrid-Methods/"},{"name":"Data Augmentation","slug":"Data-Augmentation","permalink":"https://ytz7.github.io/tags/Data-Augmentation/"},{"name":"Consistency Regularization","slug":"Consistency-Regularization","permalink":"https://ytz7.github.io/tags/Consistency-Regularization/"},{"name":"Adversarial Example","slug":"Adversarial-Example","permalink":"https://ytz7.github.io/tags/Adversarial-Example/"},{"name":"深度学习","slug":"深度学习","permalink":"https://ytz7.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"个人随笔","slug":"个人随笔","permalink":"https://ytz7.github.io/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"}]}